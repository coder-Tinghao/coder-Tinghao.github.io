<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"coder_tinghao.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Feng&#39;s Blog">
<meta property="og:url" content="http://coder_tinghao.github.io/page/2/index.html">
<meta property="og:site_name" content="Feng&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fength">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://coder_tinghao.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Feng's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Feng's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Feng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">passion</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">40</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fength"
      src="/images/profile.png">
  <p class="site-author-name" itemprop="name">Fength</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/coder-tinghao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;coder-tinghao" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:793360194@qq.com" title="E-Mail → mailto:793360194@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/11/21/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/21/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-21/" class="post-title-link" itemprop="url">java学习笔记——11.21</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-21 17:21:09 / 修改时间：22:04:47" itemprop="dateCreated datePublished" datetime="2023-11-21T17:21:09+08:00">2023-11-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><strong>b树索引</strong><br><strong>B树可以在内部节点同时存储键和值</strong>，频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率，键和值存放在内部节点和叶子节点</p>
<p><strong>b+树索引</strong><br><strong>B+树的内部节点只存放键，不存放值</strong>，叶子节点有一条链相连，天然<strong>支持范围查询</strong></p>
<p>当需要进行一次全数据遍历的时候，B+树只需 要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可</p>
<p><strong>hash索引</strong>，不支持范围查，查询效率不稳定</p>
<p>较频繁作为<strong>查询条件</strong>的字段才去创建索引，<strong>更新频繁字段</strong>不适合创建索引</p>
<h3 id="为什么用B-树而不是B树"><a href="#为什么用B-树而不是B树" class="headerlink" title="为什么用B+树而不是B树"></a>为什么用B+树而不是B树</h3><p><strong>B树</strong><br>随机检索<br>元素遍历（范围查询）效率低下</p>
<p><strong>B+树</strong><br>同时支持随机检索和顺序检索<br>内部结点不存值，比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，<strong>IO读写次数</strong>也就降低了</p>
<h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>聚簇索引：数据存储与索引放到了一块，找到索引也就找到了数据；叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据</p>
<p>非聚簇索引：数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，通过 key_buffer把索引先<strong>缓存到内存中</strong>；叶子节点存储的是主键信息，所以使用非聚簇索引还需要<strong>回表查询</strong></p>
<p>聚簇索引一般是主键索引，一个表中也只能有一个，而非聚簇索引则没有数量上的限制</p>
<h3 id="一定需要回表查询吗？"><a href="#一定需要回表查询吗？" class="headerlink" title="一定需要回表查询吗？"></a>一定需要回表查询吗？</h3><p>不一定，取决于<strong>查询语句所要求的字段是否全部命中了索引</strong>，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询</p>
<h3 id="MySQL隔离级别"><a href="#MySQL隔离级别" class="headerlink" title="MySQL隔离级别"></a>MySQL隔离级别</h3><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读 取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ(可重读)并不会有 任何性能损失<br><strong>InnoDB 存储引擎在 分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别</strong></p>
<h3 id="隔离级别和锁"><a href="#隔离级别和锁" class="headerlink" title="隔离级别和锁"></a>隔离级别和锁</h3><p>在Read Uncommitted级别下，<strong>读取数据不需要加共享锁</strong>，这样就不会跟被修<br>改的数据上的排他锁冲突</p>
<p>在Read Committed级别下，<strong>读操作需要加共享锁</strong>，但是在语句<strong>执行完以后释放共享锁</strong></p>
<p>在Repeatable Read级别下，<strong>读操作需要加共享锁，但是在事务提交之前并不释放共享锁</strong>，也就是必须等待事务执行完毕以后才释放共享锁</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成</p>
<h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><p>行级锁、表级锁、页级锁；具体还分<strong>共享锁和排他锁</strong> 还有<strong>意向锁（预先通知）</strong><br>InnoDB支持行级锁和表级锁，<strong>默认为行级锁</strong></p>
<p><strong>行级锁</strong> 开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低；并发度最高</p>
<p><strong>表级锁</strong> 开销小，加锁快;不会出现死锁（也有可能吧）;锁定粒度大，发出锁冲突的概率最高</p>
<p><strong>页级锁</strong> 中间</p>
<h3 id="MySQL行锁"><a href="#MySQL行锁" class="headerlink" title="MySQL行锁"></a>MySQL行锁</h3><p>InnoDB是基于<strong>索引</strong>来完成行锁<br>例: select * from tab_with_index where id &#x3D; 1 for update;<br>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id不是索引键那么InnoDB将 完成表锁，并发将无从谈起</p>
<h3 id="InnoDB存储引擎的锁"><a href="#InnoDB存储引擎的锁" class="headerlink" title="InnoDB存储引擎的锁"></a>InnoDB存储引擎的锁</h3><p>Record lock:单个行记录上的锁<br>Gap lock:间隙锁，锁定一个范围，不包括记录本身<br>Next-key lock:record+gap 锁定一个范围，包含记录本身</p>
<p>Gap Lock 的作用是为了<strong>阻止多个事务将记录插入到同一个范围内</strong>，因为这会导致幻读问题（phantom Problem）的产生</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>虚拟表</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/11/20/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/20/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-20/" class="post-title-link" itemprop="url">java学习笔记——11.20</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-20 19:59:31" itemprop="dateCreated datePublished" datetime="2023-11-20T19:59:31+08:00">2023-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-21 16:08:17" itemprop="dateModified" datetime="2023-11-21T16:08:17+08:00">2023-11-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>Java集合由两大接口派生：<strong>Collection接口、Map接口</strong><br>Collection接口下面，有三个主要的子接口：<strong>List、Set 和 Queue</strong></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>ArrayList，底层用**Object[]**存储，线程不安全，适用于频繁查找，支持快速随机访问（实现了RandomAccess接口）</p>
<p>Vector，底层用**Object[]**存储，线程安全</p>
<p>LinkedList底层用<strong>双向链表</strong>，一般是不会使用到LinkedList，需要用到 LinkedList的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet，底层基于HashMap实现，保存元素，用于不需要保证元素插入和取出顺序的场景</p>
<p>LinkedHashSet，通过 LinkedHashMap来实现，链表和哈希表，<strong>元素的插入和取出顺序满足 FIFO</strong></p>
<p>TreeSet，红黑树，支持对元素自定义排序规则的场景</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>PriorityQueue，Object[]数组来实现小顶堆</p>
<p>DelayQueue，只有到了其指定的延迟时间，才能够从队列中出队</p>
<p>ArrayDeque，可扩容动态双向数组</p>
<h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>双端队列，扩展了Queue接口</p>
<h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h3><p>ArrayDeque 是基于<strong>可变长的数组和双指针</strong>来实现，而 LinkedList 则通过<strong>链表</strong>实现</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>HashMap，<strong>数组+链表</strong>，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p>
<p>LinkedHashMap，</p>
<p>Hashtable，数组+链表，比HashMap多了个<strong>线程安全</strong></p>
<p>TreeMap，红黑树</p>
<p>ConcurrentHashMap，<strong>并发环境</strong>下，推荐使用</p>
<h3 id="Java集合fail-last机制"><a href="#Java集合fail-last机制" class="headerlink" title="Java集合fail-last机制"></a>Java集合fail-last机制</h3><p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件</p>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在 被遍历期间如果内容发生变化，就会改变modCount 的值。每当迭代器使用hashNext()&#x2F;next()遍历下一 个元素之前，都会检测 modCount变量是否为expectedmodCount值，是的话就返回遍历;否则抛出 异常，终止遍历</p>
<p><strong>不要在 foreach 循环里进行元素的 remove&#x2F;add 操作</strong>，remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。通过反编译你会发现 foreach 语法底层其实还是依赖 Iterator 。不过， <strong>remove&#x2F;add 操作直接调用的是集合自己的方法，而不是 Iterator 的 remove&#x2F;add方法，迭代器就会发现自己有元素被remove&#x2F;add，就抛异常了</strong></p>
<p>除了使用Iterator进行遍历操作外：<br>使用 fail-safe 的集合类，<br><strong>java.util包下面的所有的集合类都是 fail-fast 的，而java.util.concurrent包下面的所有的类都是 fail-safe</strong></p>
<h3 id="集合只读"><a href="#集合只读" class="headerlink" title="集合只读"></a>集合只读</h3><p>Collections. unmodifiableCollection(Collection c)方法来创建一个 只读集合，改变集合 的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常</p>
<h3 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h3><pre><code>List&lt;String&gt; list = new ArrayList
Iterator&lt;String&gt; it = list. iterator
while(it. hasNext())&#123;
    String obj = it. next();
    System. out. println(obj);
&#125;
</code></pre>
<p>在当前遍历 的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常，如果要删除元素就用iterator.remove()</p>
<h3 id="Iterator与ListIterator"><a href="#Iterator与ListIterator" class="headerlink" title="Iterator与ListIterator"></a>Iterator与ListIterator</h3><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List<br>Iterator 只能<strong>单向遍历</strong>，而 ListIterator 可以<strong>双向遍历(向前&#x2F;后遍历)</strong></p>
<h3 id="List遍历的最佳实践"><a href="#List遍历的最佳实践" class="headerlink" title="List遍历的最佳实践"></a>List遍历的最佳实践</h3><p><strong>支持 Random Access 的列表可用 for 循环遍历，否则建议 用 Iterator 或 foreach 遍历</strong></p>
<h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p>Comparable 接口实际上是出自java.lang包，它有一个 c**ompareTo(Object obj)**方法用来排序</p>
<p>Comparator接口实际上是出自 java.util 包它有一个c**ompare(Object obj1, Object obj2)**方法用来排序</p>
<h3 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h3><p><strong>可以利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作</strong>，避免使用 List 的 contains() 进行遍历去重或者判断包含操作</p>
<p>HashSet 的 contains() 方法底部依赖的 HashMap 的 containsKey() 方法，时间复杂度接近于<strong>O（1）</strong></p>
<p>ArrayList 的 contains() 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 <strong>O(n)</strong></p>
<h3 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h3><p>当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 List 的唯一元素就是这个数组</p>
<p>Arrays.asList()方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类</p>
<p>List.of()方法适用于需要创建一组固定的、不可变的元素列表的场景</p>
<h3 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h3><p>处理纯文本数据，优先考虑使用字符流，除此之外都使用字节流</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/10/12/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9410-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/12/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9410-12/" class="post-title-link" itemprop="url">java学习笔记——10.12</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-12 12:37:11" itemprop="dateCreated datePublished" datetime="2023-10-12T12:37:11+08:00">2023-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-13 20:13:06" itemprop="dateModified" datetime="2023-10-13T20:13:06+08:00">2023-10-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><pre><code>assert condition;
assert condition: expression;
</code></pre>
<p>expression表达式部分为了<strong>生成一个消息字符串</strong></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p><strong>Java虚拟机没有泛型类型对象，所有对象都属于普通类</strong><br>对于一个泛型类型，都会自动提供一个<strong>原始类型</strong><br>对于无限定的类型变量，会被替换为Object；对于有限定的，用第一个限定来替换类型变量<br>例如：List<T> 在运行时被视为List<Object></p>
<h4 id="Java桥方法"><a href="#Java桥方法" class="headerlink" title="Java桥方法"></a>Java桥方法</h4><p>虚拟机合成桥方法以保持多态<br>暂时没看懂。。。</p>
<p>泛型类型继承机制<br>考虑一个类和一个子类Employee和Manager，<strong>Pair<Manager>不是Pair<Employee>的子类型</strong></p>
<h4 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h4><p>没看懂</p>
<h4 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h4><p>没看懂</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/10/05/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9410-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/05/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9410-9/" class="post-title-link" itemprop="url">java学习笔记——10.9</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-05 21:10:41" itemprop="dateCreated datePublished" datetime="2023-10-05T21:10:41+08:00">2023-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-14 20:34:22" itemprop="dateModified" datetime="2023-10-14T20:34:22+08:00">2023-10-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><strong>为什么不用抽象类表示通用属性？</strong><br>java中没有多重继承，每个类只能扩展一个类，那比如一个类想扩展多个抽象功能，就做不到了<br>接口提供多重继承，每个类可以实现任意多个接口</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调函数（callback function）所指的是一个函数作为参数传递到另一个函数，并且它将在某些“事件”（条件判定、函数调用、按钮点击事件或者是计时器计时等）触发后被调用执行，以完成我们指定的任务</p>
<h3 id="克隆与拷贝"><a href="#克隆与拷贝" class="headerlink" title="克隆与拷贝"></a>克隆与拷贝</h3><p>拷贝：原变量和副本都是同一个对象的引用（引用拷贝）<br>克隆：是copy一个新对象，初始状态和原来相同，需要使用<strong>clone()方法</strong></p>
<p>所有数组类型都有一个公共的clone方法，且不受保护</p>
<pre><code>int[] a = &#123;1,2,3,4,5&#125;;
int[] b = a.clone()
b[4] = 2; // 不会改变a数组中的值
</code></pre>
<h4 id="深拷贝和浅拷贝-（java核心技术P248）"><a href="#深拷贝和浅拷贝-（java核心技术P248）" class="headerlink" title="深拷贝和浅拷贝 （java核心技术P248）"></a>深拷贝和浅拷贝 （java核心技术P248）</h4><p>暂时浅浅理解</p>
<p>浅拷贝：克隆的默认操作，没有克隆对象中引用的其他对象<br>深拷贝：深拷贝把要复制的对象<strong>所引用的对象</strong>都复制了一遍<br>这两种拷贝都叫<strong>对象拷贝</strong></p>
<h3 id="lambda表达式及函数式接口"><a href="#lambda表达式及函数式接口" class="headerlink" title="lambda表达式及函数式接口"></a>lambda表达式及函数式接口</h3><p><strong>函数式接口就是只有一个抽象方法的接口</strong>，比如典型的Comparator接口就是只有一个方法的接口（就一个函数，像个函数似的但是是接口，就叫函数式接口，没毛病）<br>对于Arrays.sort(xx, xx)  这个sort方法会接收实现了Comparator<String>某个类的对象，在对象上调用compare方法</p>
<p>设计函数式接口时，可以加上@<strong>FunctionalInterface注解</strong>，用于检查是否只有一个抽象方法和javadoc页可以指出这是一个函数式接口</p>
<pre><code>@FunctionalInterface
interface MathOperation &#123;
    int operate(int a, int b);
&#125;

MathOperation addition = (a, b) -&gt; a + b; // 使用Lambda表达式来创建函数式接口的实例
int result = addition.operate(5, 3); // 调用MathOperation接口的operate方法
System.out.println(result); // 输出8
</code></pre>
<p>lambda表达式可以转换为接口（只转换为函数式接口）<br><strong>把lambda表达式看作一个函数</strong>，而不是对象，且可以传递到函数式接口<br>lambda表达式可以捕获外围作用域的<strong>事实最终变量（初始化后就不再被赋新值）</strong></p>
<p><strong>和c++的区别就是</strong>：c++传的是个函数指针，java传的是个实现了这个接口的类的对象，从这个对象调这个函数</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用是用来简化Lambda表达式的一种方式，它可以将已存在的方法引用为Lambda表达式的实现，方法引用适用于Lambda表达式的签名与被引用方法的签名兼容的情况</p>
<p>包括静态方法、实例方法、构造方法<br>（具体见《java核心技术》P258）</p>
<h3 id="java代理"><a href="#java代理" class="headerlink" title="java代理"></a>java代理</h3><p>涉及反射，后续看完反射回头看</p>
<h3 id="java容器"><a href="#java容器" class="headerlink" title="java容器"></a>java容器</h3><h4 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h4><p>认为Java迭代器位于两个元素之间，调用next，迭代器会越过下一个元素，并返回越过的这个元素的引用<br>迭代器必须顺序访问集合</p>
<p><strong>ListIterator接口</strong>有两个方法可以反向遍历链表</p>
<pre><code>E previous()
boolean hasPrevious()
</code></pre>
<p>与next方法一样，previous方法会返回越过的对象</p>
<h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p>Vector的所有方法是<strong>同步的</strong>，线程安全<br>ArrayList方法不是同步的</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>Java中，散列表的实现为链表数组，每个列表为桶；当桶满时，链表会变为平衡二叉树</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>与散列集很像，是一个有序集合，遍历时自动按照排序后顺序出现（排序目前用的是红黑树）；且HashSet稍快一些<br>要使用这个TreeSet，元素必须实现Comparable接口或者提供Comparator</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/29/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/29/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-29/" class="post-title-link" itemprop="url">java学习笔记——9.29</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-29 11:45:19" itemprop="dateCreated datePublished" datetime="2023-09-29T11:45:19+08:00">2023-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-05 22:24:22" itemprop="dateModified" datetime="2023-10-05T22:24:22+08:00">2023-10-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>java new出来的对象都<strong>大多</strong>是在堆中构造的，不绝对</p>
<h3 id="java-var关键字"><a href="#java-var关键字" class="headerlink" title="java var关键字"></a>java var关键字</h3><p>var关键字用于<strong>局部变量的类型推导</strong>，参数和字段的类型必须声明</p>
<h3 id="java类"><a href="#java类" class="headerlink" title="java类"></a>java类</h3><p>只访问对象而不修改对象——<strong>访问器方法</strong></p>
<pre><code>getXXX() &#123;
    
&#125;
</code></pre>
<p>能修改的——<strong>修改器方法</strong></p>
<pre><code>setXXX() &#123;

&#125;
</code></pre>
<h3 id="null引用"><a href="#null引用" class="headerlink" title="null引用"></a>null引用</h3><p>没有任何引用对象</p>
<pre><code>// 对象引用参数为null时，转化为非null值
public Emmployee(String name, int age) &#123;
    name = Objects.requireNonNullElse(n, &quot;unknown&quot;);
&#125;

// 对象引用参数为null时，产生异常
// 但可以准确定位，会提供问题描述
public Emmployee(String name, int age) &#123;
    name = Objects.requireNonNull(n, &quot;name cannot be null&quot;);
&#125;
</code></pre>
<h3 id="方法参数（java核心技术P122）"><a href="#方法参数（java核心技术P122）" class="headerlink" title="方法参数（java核心技术P122）"></a>方法参数（java核心技术P122）</h3><p>参数类型：基本数据类型，对象引用</p>
<p>java中总是采用<strong>按值传递</strong>，方法不可能修改基本数据类型的参数</p>
<p>传入一个<strong>对象参数</strong>就可以实现修改</p>
<p>原因：Java中实际上对象引用也是按值传递的<br>参数传一个对象引用，因为是值传递，可以获得一个对象引用的副本（个人理解：就是传入这个对象地址值的副本，和远对象引用指向同一个对象）那么这个对象引用的副本就可以操作这个对象修改所引用对象的状态</p>
<h3 id="java记录"><a href="#java记录" class="headerlink" title="java记录"></a>java记录</h3><p>特殊类，状态不可变，公共可读</p>
<pre><code>record Point(double x, double y) &#123; &#125;
var p = new Point(3, 4);
sout(p.x() + p.y());
</code></pre>
<p>访问器方法名为变量名</p>
<h3 id="java静态绑定和动态绑定"><a href="#java静态绑定和动态绑定" class="headerlink" title="java静态绑定和动态绑定"></a>java静态绑定和动态绑定</h3><p>静态绑定发生在编译时期，动态绑定发生在运行时</p>
<p>使用private或static或final修饰的变量或者方法，编译器可以准确的知道可以调用哪个方法，使用静态绑定<br>可以被子类重写的方法则会根据运行时的对象进行动态绑定</p>
<p>动态绑定过程：<br>jvm会为每个类生成一个<strong>方法表</strong>，方便在调用方法时查找该用哪个方法</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p><strong>toString方法</strong><br>返回一个表示对象的值的字符串<br>用法：例如下面的代码，常用于自定义toString方法，来<strong>方便获取和打印对象状态</strong>的有用信息</p>
<pre><code>public String toString() &#123;
    return getClass().getName()
    + &quot;name=&quot; + name;
&#125;
</code></pre>
<h3 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h3><p>如：Integer对应int<br><strong>包装器类是不可变的，不允许更改里面的值</strong>，且是final的</p>
<h3 id="密封类sealed"><a href="#密封类sealed" class="headerlink" title="密封类sealed"></a>密封类sealed</h3><p>可以控制哪些类可以继承他</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/26/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/26/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-26/" class="post-title-link" itemprop="url">java学习笔记——9.26</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-26 20:28:45" itemprop="dateCreated datePublished" datetime="2023-09-26T20:28:45+08:00">2023-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-05 22:08:57" itemprop="dateModified" datetime="2023-12-05T22:08:57+08:00">2023-12-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Java类型转换"><a href="#Java类型转换" class="headerlink" title="Java类型转换"></a>Java类型转换</h3><p>long类型比float类型表示的范围小</p>
<p><strong>byte、char、short类型在做运算过程中，会自动提升为int类型</strong></p>
<pre><code>    byte a = 3;
    byte b = 4;
    byte c = a + b;  // 会报错，因为运算时提升成int了
    byte c = (byte)(a+b); // int转byte，大转小，用强制类型转换
    byte c = 3 + 4;  // 不会报错，因为上面的运算是变量，这行代码是两个字面量
</code></pre>
<p>**Java有常量优化机制：编译期间会对3+4进行计算，实际的字节码文件：byte c&#x3D;7;对于String类型，也有常量优化机制，String s &#x3D; “a” +  **</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>java字符串，String类对象<strong>不可变</strong></p>
<p>优点：编译器可以让字符串<strong>共享</strong></p>
<p>字符串字面值存放在<strong>常量池</strong>（也是在堆内存中）</p>
<pre><code>    String s1 = &quot;abc&quot;; // 通过赋值的方式初始化
    String s2 = &quot;abc&quot;;
    System.out.println(s1==s2); // 返回true，说明在常量池的同一个地方
</code></pre>
<p>若通过new初始化，则在堆内存中，不在常量池中</p>
<pre><code>    String s1 = new String(&quot;abc&quot;);
    String s2 = new String(&quot;abc&quot;);
    System.out.println(s1==s2); // 返回false，说明s2创建时，在堆内存中又新建了一个“abc”对象
</code></pre>
<p>所以，通过直接赋值的方式进行初始化还可以节省空间</p>
<h4 id="检测字符串相等"><a href="#检测字符串相等" class="headerlink" title="检测字符串相等"></a>检测字符串相等</h4><p>用.equals()方法检测</p>
<p>&#x3D;&#x3D; 运算符只能确定两个字符串是否存放在同一位置<br>只有字符串字面值会共享，+和substring得到的字符串不共享</p>
<h4 id="空串与null"><a href="#空串与null" class="headerlink" title="空串与null"></a>空串与null</h4><p>空串是一个对象，长度为0，内容为空</p>
<pre><code>    str.length() == 0;
    str.equals(&quot;&quot;);
</code></pre>
<p>null表示没有任何对象与该变量相关联</p>
<pre><code>    str === null
</code></pre>
<h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>StringBuilder和StringBuffer都可以理解成容器，用于<strong>支持String修改操作</strong></p>
<p><strong>StringBuilder</strong><br>如果所有字符串编辑操作都单线程执行，应当使用StringBuilder</p>
<pre><code>    StringBuilder sb = new StringBuilder();
    sb.append(str1);
    sb.append(str2);
    String ret = sb.toString();
</code></pre>
<p><strong>源码分析</strong><br>长度 .length() ：实际存了多少<br>容量 .capacity() :最多可以存多少<br>初始容量为<strong>指定字符串 +16</strong>，若初始化时为空，容量就是16；也可以指定容量</p>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>若不够，先扩容为2倍+2；若还不够，扩容为字符串实际长度<br>扩容就是创建一个新容量的byte数组，把字符串内容复制进去，再返回</p>
<p><strong>StringBuffer</strong><br>与StringBuilder类似，没有StringBuilder速度快，多数情况下用Builder<br>但是，StringBuilder不是线程安全的，<strong>若要求线程安全必须用StringBuffer</strong></p>
<p><strong>原因</strong>：StringBuffer中所有方法都是synchronized修饰的，同一时间只能有一个线程访问，StringBuilder中的操作有非原子操作。但是实际情况中，String的构建几乎不涉及多线程场景</p>
<p><strong>StringJoiner</strong><br>StringJoiner基于StringBuilder构建的适用于<strong>字符拼接</strong>的场景</p>
<pre><code>    StringJoiner sj = new StringJoiner(&quot;,&quot;); // 指定分隔符
    sj.add(&quot;张三&quot;).add(&quot;李四&quot;).add(&quot;王五&quot;); // 添加元素
    String result = sj.toString(); // 转换为字符串
    System.out.println(result); // 张三,李四,王五
</code></pre>
<h3 id="字符串拼接底层原理"><a href="#字符串拼接底层原理" class="headerlink" title="字符串拼接底层原理"></a>字符串拼接底层原理</h3><p>如果没有变量参与，编译时会进行优化，<strong>编译时拼接起来，会复用常量池中的字符串</strong></p>
<pre><code>    String s1 = &quot;abc&quot;;
    String s2 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;
    System.out.println(s1==s2); // 返回true，
</code></pre>
<p>如果有变量参与，每一行拼接都会在内存中创建新字符串对象，浪费内存</p>
<h4 id="StringBuilder优化原理"><a href="#StringBuilder优化原理" class="headerlink" title="StringBuilder优化原理"></a>StringBuilder优化原理</h4><p>创建一次StringBuilder对象，所有要拼接的都往这一个对象放，节约内存</p>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>java不允许在嵌套的块中重定义变量<br>java不能实现运算符重载</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>快速打印数组</p>
<pre><code>    int[] a = new int[100];
    System.out.println(Arrays.toString(a));
</code></pre>
<p>快速打印二维数组</p>
<pre><code>    int[] a = new int[100][100];
    System.out.println(Arrays.deeptoString(a));
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/21/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/21/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-21/" class="post-title-link" itemprop="url">c++学习笔记——9.21</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-21 08:55:01 / 修改时间：12:42:53" itemprop="dateCreated datePublished" datetime="2023-09-21T08:55:01+08:00">2023-09-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h3><pre><code>    int ia[] = &#123;0, 1, 2, 3&#125;;
    int *beg = begin(ia); // 指向ia首元素的指针
    int *last = end(ia); // 指向ia尾元素的下一个位置的指针
</code></pre>
<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>当一个对象被用作右值，用的是对象的<strong>值（内容）</strong><br>当一个对象被用作左值，用的是对象的<strong>身份（在内存中的位置）</strong></p>
<h3 id="自增-自减运算符"><a href="#自增-自减运算符" class="headerlink" title="自增 自减运算符"></a>自增 自减运算符</h3><p><strong>除非必须，否则不用自增自减运算符的后置版本（i++）</strong><br>原因：后置版本会先将原始值存储下来，不必要</p>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p>函数中不会改变的形参定义为<strong>常量引用</strong></p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>1 如果所有实参类型相同，可用initialzer_list（标准库类型），initialzer_list是一个模版类型<br>        void error_msg(initialzer_list<string> i) {<br>            …<br>        }</p>
<p>2 如果实参类型不同，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/20/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/20/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-20/" class="post-title-link" itemprop="url">c++学习笔记——9.20</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-20 10:27:06 / 修改时间：12:03:56" itemprop="dateCreated datePublished" datetime="2023-09-20T10:27:06+08:00">2023-09-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>对于c++的迭代器，<strong>只有!&#x3D;</strong> 没有&lt;</p>
<p>迭代器分为两种：<br>        vector<int>::iterator it1;  &#x2F;&#x2F; 能读写<br>        vector<int>::const_iterator it2;  &#x2F;&#x2F; 只读，不能写<br>若想得到const_iterator，有<strong>cbegin(),cend();</strong></p>
<p><strong>但凡使用迭代器的循环体，都不要向容器添加元素</strong></p>
<p><strong>std::difference_type</strong> 是C++标准库中的一种类型，通常与容器迭代器相关。它是一个有符号整数类型，用于表示两个迭代器之间的距离（差异）</p>
<p>与size_type()函数类似 <strong>目的是确保在不同平台和编译器中，容器迭代器的距离计算都能正确工作，因为不同的平台和编译器可能会有不同的整数大小，保证可移植性</strong></p>
<h3 id="size-t和size-type的区别（来自chatgpt，未完全理解）"><a href="#size-t和size-type的区别（来自chatgpt，未完全理解）" class="headerlink" title="size_t和size_type的区别（来自chatgpt，未完全理解）"></a>size_t和size_type的区别（来自chatgpt，未完全理解）</h3><p><strong>size_t：</strong> size_t是C和C++<strong>标准库</strong>中定义的一种无符号整数类型，通常用于表示对象的大小、元素数量或者数组的索引，它不是一个特定容器或类型的成员</p>
<p><strong>size_type：</strong> size_type是一些<strong>标准库容器类</strong>的成员类型，例如 std::vector、std::string、std::deque等，是<strong>容器类特定</strong>的无符号整数类型，用于表示容器的大小、元素数量或者迭代器之间的距离。</p>
<p>在使用容器的成员函数时，应该使用容器的 size_type 类型，以确保代码在容器的上下文中正常工作。例如，在使用 std::vector 时，应该使用 std::vector::size_type 来表示容器的大小。</p>
<h3 id="箭头运算符-gt"><a href="#箭头运算符-gt" class="headerlink" title="箭头运算符 -&gt;"></a>箭头运算符 -&gt;</h3><p>箭头运算符 &#x3D; 解引用 + 成员访问<br>        it-&gt;mem<br>        (*it).mem<br>上面两句意思相同</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>编译时维度已知，所以维度必须是一个<strong>常量表达式</strong></p>
<p><strong>字符数组：用字符串字面值初始化字符数组时，字符串字面值的结尾有一个空字符</strong><br>        char a[] &#x3D; “Daniel”； &#x2F;&#x2F; 自动添加表示空字符串结束的空字符，所以维度为7</p>
<p><strong>使用数组下标时，通常定义为size_t类型</strong>，是一种机器相关的<strong>无符号类型</strong><br>size_t 的大小在不同的编译器和平台上可能会有所不同，但它的目的是确保能够安全地表示当前系统上的最大对象大小<br>通常被用于与内存分配和数据结构相关的操作，以确保代码的可移植性</p>
<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>从内向外看<br>int *ptr[10]; &#x2F;&#x2F; ptr是含有10个整型指针的数组<br>int (*ptr)[10] &#x3D; &amp;arr; &#x2F;&#x2F; ptr指向一个含有10个整数的数组</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/17/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/17/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-17/" class="post-title-link" itemprop="url">c++学习笔记——9.17</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-17 14:20:55" itemprop="dateCreated datePublished" datetime="2023-09-17T14:20:55+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-19 20:25:47" itemprop="dateModified" datetime="2023-09-19T20:25:47+08:00">2023-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h3><p>c++ 静态类型语言，在编译阶段检查类型</p>
<h3 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h3><p><strong>赋值永远改变的是等号左侧的对象</strong></p>
<h3 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h3><p>引用类型必须与其所引用对象的类型一致<br>        const int ci &#x3D; 1024;<br>        const int &amp;r1 &#x3D; ci;</p>
<p>常量引用：常量引用是对const的引用</p>
<p>对const的引用可能引用一个非const对象：<br>常量引用，即对引用加const，只是<strong>限定了引用可参与的操作</strong>，对于引用的对象本身没有限定<br>        int i &#x3D; 42;<br>        const int &amp;r1 &#x3D; i;<br>        r1 &#x3D; 0;  &#x2F;&#x2F; <strong>非法，常量引用不能修改</strong></p>
<h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><p>指向常量的指针和常量引用类似，<br>        const int i &#x3D; 42;<br>        const int *i &#x3D; &amp;i;<br>        *i &#x3D; 0;  &#x2F;&#x2F; <strong>非法，不能修改值</strong></p>
<h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><pre><code>    const int i = 42;
    const int *const r1 = &amp;i;
</code></pre>
<p>*<strong>const为const指针，不变的是指针本身的值，而指向的值</strong></p>
<h3 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h3><p>顶层 const 表示指针本身是个常量；<br>底层 const 表示指针所指的对象是一个常量<br>or<br>被修饰的变量本身无法改变的 const 是顶层 const；<br>通过指针或引用等间接途径来限制目标内容不可变的 const 是底层 const</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>常量表达式：值不会改变，编译过程就能得到计算结果的表达式</p>
<p>C++11:constexpr，如果认定变量是常量表达式，就声明为constexpr</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>别名声明<br>    using SI &#x3D; Sales_item;  &#x2F;&#x2F; SI是Sales_item的同义词（Sales_item是一个类型）</p>
<h3 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h3><p>预处理功能 #include，当预处理器看到#include标记时就会用指定的头文件内容代替#include</p>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>选择并返回操作数的数据类型<br>使用情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量</p>
<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h3><p>string类的配套类型，<strong>无符号类型</strong>，能足够存放下任何string对象的大小（通常等于 std::size_t）<br>访问string对象的下标也是size_type类型，<strong>使用该类型访问string中的字符可以保证安全（无符号）</strong></p>
<p>注：size()函数无符号，要避免和int类型混用带来的问题</p>
<h3 id="int类型和unsigned-int类型混用问题"><a href="#int类型和unsigned-int类型混用问题" class="headerlink" title="int类型和unsigned int类型混用问题"></a>int类型和unsigned int类型混用问题</h3><p>int和unsigned int类型进行混合算数运算时，运算结果为<strong>非负数时，结果不会出现异常</strong>，当运算结果为<strong>负数时就会出现异常结果，往往异常结果值会很大</strong></p>
<h3 id="字面值与string对象"><a href="#字面值与string对象" class="headerlink" title="字面值与string对象"></a>字面值与string对象</h3><p>字符串字面值和string是不同的类型<br>        string s1 &#x3D; “hello”;<br>        string s2 &#x3D; s1 + “test”;  &#x2F;&#x2F; 正确，会转化为string类型<br>        string “hello” + “test”;  &#x2F;&#x2F; 错误，两个都不是string类型</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/15/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/15/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-15/" class="post-title-link" itemprop="url">c++学习笔记——9.15</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-15 14:44:37" itemprop="dateCreated datePublished" datetime="2023-09-15T14:44:37+08:00">2023-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 14:20:04" itemprop="dateModified" datetime="2023-09-17T14:20:04+08:00">2023-09-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="缓冲区（buffer）"><a href="#缓冲区（buffer）" class="headerlink" title="缓冲区（buffer）"></a>缓冲区（buffer）</h3><p>一个存储区域，用于保存数据，IO设施通常将输入输出数据保存在一个缓冲区中，可以显式刷新缓冲区</p>
<h3 id="iostream对象"><a href="#iostream对象" class="headerlink" title="iostream对象"></a>iostream对象</h3><p><strong>cerr</strong>  ostream对象，标准错误流，默认不缓冲，用于输出错误信息或其他不属于程序正常逻辑的输出内容</p>
<p><strong>clog</strong> ostream对象，标准错误流，有缓冲，用于报告程序执行信息</p>
<h3 id="endl与’-n’区别"><a href="#endl与’-n’区别" class="headerlink" title="endl与’\n’区别"></a>endl与’\n’区别</h3><p>endl相当于 ‘\n’+flush()</p>
<h3 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h3><p>1 明确数值不可能为负时，选无符号<br>2 选int做整数运算，超过int用long long<br>3 选double做浮点数运算</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是具有某种数据类型的内存空间</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><ol>
<li>每个源文件（.cpp .cc等）都是一个<strong>独立的编译单元</strong>，都会被编译一遍，并生成中间文件。在 main.cpp 里，include用来【编译】时找函数声明，中间文件用来【链接】时找函数原型。</li>
<li>include简单的说就是复制粘贴而已，每个正常的头文件都会预防重复包含，如使用 #pramga once，#ifndef 等。</li>
</ol>
<p><strong>声明与定义</strong><br>c++将声明和定义区分开</p>
<p>声明 (declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明</p>
<p>定义(definition)负责<strong>创建</strong>与名字关联的实体</p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键字 extern，而且不要显式地初始化变量</p>
<pre><code>extern int i  //声明i，非定义i
int j  // 声明并定义j
</code></pre>
<p>另外，任何包含了显式初始化的声明即成为定义，如下：<br>    extern double pi &#x3D; 3.1416  &#x2F;&#x2F; 定义</p>
<h3 id="初始化建议"><a href="#初始化建议" class="headerlink" title="初始化建议"></a>初始化建议</h3><p>初始化每一个内置类型的变量</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fength</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
