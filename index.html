<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"coder_tinghao.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Feng&#39;s Blog">
<meta property="og:url" content="http://coder_tinghao.github.io/index.html">
<meta property="og:site_name" content="Feng&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fength">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://coder_tinghao.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Feng's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Feng's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Feng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">passion</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">28</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fength"
      src="/images/profile.png">
  <p class="site-author-name" itemprop="name">Fength</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/coder-tinghao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;coder-tinghao" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:793360194@qq.com" title="E-Mail → mailto:793360194@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/10/12/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9410-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/12/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9410-12/" class="post-title-link" itemprop="url">java学习笔记——10.12</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-12 12:37:11" itemprop="dateCreated datePublished" datetime="2023-10-12T12:37:11+08:00">2023-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-13 20:13:06" itemprop="dateModified" datetime="2023-10-13T20:13:06+08:00">2023-10-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><pre><code>assert condition;
assert condition: expression;
</code></pre>
<p>expression表达式部分为了<strong>生成一个消息字符串</strong></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p><strong>Java虚拟机没有泛型类型对象，所有对象都属于普通类</strong><br>对于一个泛型类型，都会自动提供一个<strong>原始类型</strong><br>对于无限定的类型变量，会被替换为Object；对于有限定的，用第一个限定来替换类型变量<br>例如：List<T> 在运行时被视为List<Object></p>
<h4 id="Java桥方法"><a href="#Java桥方法" class="headerlink" title="Java桥方法"></a>Java桥方法</h4><p>虚拟机合成桥方法以保持多态<br>暂时没看懂。。。</p>
<p>泛型类型继承机制<br>考虑一个类和一个子类Employee和Manager，<strong>Pair<Manager>不是Pair<Employee>的子类型</strong></p>
<h4 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h4><p>没看懂</p>
<h4 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h4><p>没看懂</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/10/05/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9410-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/05/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9410-9/" class="post-title-link" itemprop="url">java学习笔记——10.9</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-05 21:10:41" itemprop="dateCreated datePublished" datetime="2023-10-05T21:10:41+08:00">2023-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-14 20:34:22" itemprop="dateModified" datetime="2023-10-14T20:34:22+08:00">2023-10-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><strong>为什么不用抽象类表示通用属性？</strong><br>java中没有多重继承，每个类只能扩展一个类，那比如一个类想扩展多个抽象功能，就做不到了<br>接口提供多重继承，每个类可以实现任意多个接口</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调函数（callback function）所指的是一个函数作为参数传递到另一个函数，并且它将在某些“事件”（条件判定、函数调用、按钮点击事件或者是计时器计时等）触发后被调用执行，以完成我们指定的任务</p>
<h3 id="克隆与拷贝"><a href="#克隆与拷贝" class="headerlink" title="克隆与拷贝"></a>克隆与拷贝</h3><p>拷贝：原变量和副本都是同一个对象的引用（引用拷贝）<br>克隆：是copy一个新对象，初始状态和原来相同，需要使用<strong>clone()方法</strong></p>
<p>所有数组类型都有一个公共的clone方法，且不受保护</p>
<pre><code>int[] a = &#123;1,2,3,4,5&#125;;
int[] b = a.clone()
b[4] = 2; // 不会改变a数组中的值
</code></pre>
<h4 id="深拷贝和浅拷贝-（java核心技术P248）"><a href="#深拷贝和浅拷贝-（java核心技术P248）" class="headerlink" title="深拷贝和浅拷贝 （java核心技术P248）"></a>深拷贝和浅拷贝 （java核心技术P248）</h4><p>暂时浅浅理解</p>
<p>浅拷贝：克隆的默认操作，没有克隆对象中引用的其他对象<br>深拷贝：深拷贝把要复制的对象<strong>所引用的对象</strong>都复制了一遍<br>这两种拷贝都叫<strong>对象拷贝</strong></p>
<h3 id="lambda表达式及函数式接口"><a href="#lambda表达式及函数式接口" class="headerlink" title="lambda表达式及函数式接口"></a>lambda表达式及函数式接口</h3><p><strong>函数式接口就是只有一个抽象方法的接口</strong>，比如典型的Comparator接口就是只有一个方法的接口（就一个函数，像个函数似的但是是接口，就叫函数式接口，没毛病）<br>对于Arrays.sort(xx, xx)  这个sort方法会接收实现了Comparator<String>某个类的对象，在对象上调用compare方法</p>
<p>设计函数式接口时，可以加上@<strong>FunctionalInterface注解</strong>，用于检查是否只有一个抽象方法和javadoc页可以指出这是一个函数式接口</p>
<pre><code>@FunctionalInterface
interface MathOperation &#123;
    int operate(int a, int b);
&#125;

MathOperation addition = (a, b) -&gt; a + b; // 使用Lambda表达式来创建函数式接口的实例
int result = addition.operate(5, 3); // 调用MathOperation接口的operate方法
System.out.println(result); // 输出8
</code></pre>
<p>lambda表达式可以转换为接口（只转换为函数式接口）<br><strong>把lambda表达式看作一个函数</strong>，而不是对象，且可以传递到函数式接口<br>lambda表达式可以捕获外围作用域的<strong>事实最终变量（初始化后就不再被赋新值）</strong></p>
<p><strong>和c++的区别就是</strong>：c++传的是个函数指针，java传的是个实现了这个接口的类的对象，从这个对象调这个函数</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用是用来简化Lambda表达式的一种方式，它可以将已存在的方法引用为Lambda表达式的实现，方法引用适用于Lambda表达式的签名与被引用方法的签名兼容的情况</p>
<p>包括静态方法、实例方法、构造方法<br>（具体见《java核心技术》P258）</p>
<h3 id="java代理"><a href="#java代理" class="headerlink" title="java代理"></a>java代理</h3><p>涉及反射，后续看完反射回头看</p>
<h3 id="java容器"><a href="#java容器" class="headerlink" title="java容器"></a>java容器</h3><h4 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h4><p>认为Java迭代器位于两个元素之间，调用next，迭代器会越过下一个元素，并返回越过的这个元素的引用<br>迭代器必须顺序访问集合</p>
<p><strong>ListIterator接口</strong>有两个方法可以反向遍历链表</p>
<pre><code>E previous()
boolean hasPrevious()
</code></pre>
<p>与next方法一样，previous方法会返回越过的对象</p>
<h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p>Vector的所有方法是<strong>同步的</strong>，线程安全<br>ArrayList方法不是同步的</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>Java中，散列表的实现为链表数组，每个列表为桶；当桶满时，链表会变为平衡二叉树</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>与散列集很像，是一个有序集合，遍历时自动按照排序后顺序出现（排序目前用的是红黑树）；且HashSet稍快一些<br>要使用这个TreeSet，元素必须实现Comparable接口或者提供Comparator</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/29/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/29/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-29/" class="post-title-link" itemprop="url">java学习笔记——9.29</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-29 11:45:19" itemprop="dateCreated datePublished" datetime="2023-09-29T11:45:19+08:00">2023-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-05 22:24:22" itemprop="dateModified" datetime="2023-10-05T22:24:22+08:00">2023-10-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>java new出来的对象都<strong>大多</strong>是在堆中构造的，不绝对</p>
<h3 id="java-var关键字"><a href="#java-var关键字" class="headerlink" title="java var关键字"></a>java var关键字</h3><p>var关键字用于<strong>局部变量的类型推导</strong>，参数和字段的类型必须声明</p>
<h3 id="java类"><a href="#java类" class="headerlink" title="java类"></a>java类</h3><p>只访问对象而不修改对象——<strong>访问器方法</strong></p>
<pre><code>getXXX() &#123;
    
&#125;
</code></pre>
<p>能修改的——<strong>修改器方法</strong></p>
<pre><code>setXXX() &#123;

&#125;
</code></pre>
<h3 id="null引用"><a href="#null引用" class="headerlink" title="null引用"></a>null引用</h3><p>没有任何引用对象</p>
<pre><code>// 对象引用参数为null时，转化为非null值
public Emmployee(String name, int age) &#123;
    name = Objects.requireNonNullElse(n, &quot;unknown&quot;);
&#125;

// 对象引用参数为null时，产生异常
// 但可以准确定位，会提供问题描述
public Emmployee(String name, int age) &#123;
    name = Objects.requireNonNull(n, &quot;name cannot be null&quot;);
&#125;
</code></pre>
<h3 id="方法参数（java核心技术P122）"><a href="#方法参数（java核心技术P122）" class="headerlink" title="方法参数（java核心技术P122）"></a>方法参数（java核心技术P122）</h3><p>参数类型：基本数据类型，对象引用</p>
<p>java中总是采用<strong>按值传递</strong>，方法不可能修改基本数据类型的参数</p>
<p>传入一个<strong>对象参数</strong>就可以实现修改</p>
<p>原因：Java中实际上对象引用也是按值传递的<br>参数传一个对象引用，因为是值传递，可以获得一个对象引用的副本（个人理解：就是传入这个对象地址值的副本，和远对象引用指向同一个对象）那么这个对象引用的副本就可以操作这个对象修改所引用对象的状态</p>
<h3 id="java记录"><a href="#java记录" class="headerlink" title="java记录"></a>java记录</h3><p>特殊类，状态不可变，公共可读</p>
<pre><code>record Point(double x, double y) &#123; &#125;
var p = new Point(3, 4);
sout(p.x() + p.y());
</code></pre>
<p>访问器方法名为变量名</p>
<h3 id="java静态绑定和动态绑定"><a href="#java静态绑定和动态绑定" class="headerlink" title="java静态绑定和动态绑定"></a>java静态绑定和动态绑定</h3><p>静态绑定发生在编译时期，动态绑定发生在运行时</p>
<p>使用private或static或final修饰的变量或者方法，编译器可以准确的知道可以调用哪个方法，使用静态绑定<br>可以被子类重写的方法则会根据运行时的对象进行动态绑定</p>
<p>动态绑定过程：<br>jvm会为每个类生成一个<strong>方法表</strong>，方便在调用方法时查找该用哪个方法</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p><strong>toString方法</strong><br>返回一个表示对象的值的字符串<br>用法：例如下面的代码，常用于自定义toString方法，来<strong>方便获取和打印对象状态</strong>的有用信息</p>
<pre><code>public String toString() &#123;
    return getClass().getName()
    + &quot;name=&quot; + name;
&#125;
</code></pre>
<h3 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h3><p>如：Integer对应int<br><strong>包装器类是不可变的，不允许更改里面的值</strong>，且是final的</p>
<h3 id="密封类sealed"><a href="#密封类sealed" class="headerlink" title="密封类sealed"></a>密封类sealed</h3><p>可以控制哪些类可以继承他</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/26/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/26/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-26/" class="post-title-link" itemprop="url">java学习笔记——9.26</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-26 20:28:45" itemprop="dateCreated datePublished" datetime="2023-09-26T20:28:45+08:00">2023-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-29 18:38:13" itemprop="dateModified" datetime="2023-09-29T18:38:13+08:00">2023-09-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>java字符串，String类对象<strong>不可变</strong></p>
<p>优点：编译器可以让字符串<strong>共享</strong></p>
<p>字符串字面值存放在<strong>常量池</strong>（也是在堆内存中）</p>
<pre><code>    String s1 = &quot;abc&quot;; // 通过赋值的方式初始化
    String s2 = &quot;abc&quot;;
    System.out.println(s1==s2); // 返回true，说明在常量池的同一个地方
</code></pre>
<p>若通过new初始化，则在堆内存中，不在常量池中</p>
<pre><code>    String s1 = new String(&quot;abc&quot;);
    String s2 = new String(&quot;abc&quot;);
    System.out.println(s1==s2); // 返回false，说明s2创建时，在堆内存中又新建了一个“abc”对象
</code></pre>
<p>所以，通过直接赋值的方式进行初始化还可以节省空间</p>
<h4 id="检测字符串相等"><a href="#检测字符串相等" class="headerlink" title="检测字符串相等"></a>检测字符串相等</h4><p>用.equals()方法检测</p>
<p>&#x3D;&#x3D; 运算符只能确定两个字符串是否存放在同一位置<br>只有字符串字面值会共享，+和substring得到的字符串不共享</p>
<h4 id="空串与null"><a href="#空串与null" class="headerlink" title="空串与null"></a>空串与null</h4><p>空串是一个对象，长度为0，内容为空</p>
<pre><code>    str.length() == 0;
    str.equals(&quot;&quot;);
</code></pre>
<p>null表示没有任何对象与该变量相关联</p>
<pre><code>    str === null
</code></pre>
<h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>StringBuilder和StringBuffer都可以理解成容器，用于<strong>支持String修改操作</strong></p>
<p><strong>StringBuilder</strong><br>如果所有字符串编辑操作都单线程执行，应当使用StringBuilder</p>
<pre><code>    StringBuilder sb = new StringBuilder();
    sb.append(str1);
    sb.append(str2);
    String ret = sb.toString();
</code></pre>
<p><strong>源码分析</strong><br>长度 .length() ：实际存了多少<br>容量 .capacity() :最多可以存多少<br>初始容量为<strong>指定字符串 +16</strong>，若初始化时为空，容量就是16；也可以指定容量</p>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>若不够，先扩容为2倍+2；若还不够，扩容为字符串实际长度<br>扩容就是创建一个新容量的byte数组，把字符串内容复制进去，再返回</p>
<p><strong>StringBuffer</strong><br>与StringBuilder类似，没有StringBuilder速度快，多数情况下用Builder<br>但是，StringBuilder不是线程安全的，<strong>若要求线程安全必须用StringBuffer</strong></p>
<p><strong>原因</strong>：StringBuffer中所有方法都是synchronized修饰的，同一时间只能有一个线程访问，StringBuilder中的操作有非原子操作。但是实际情况中，String的构建几乎不涉及多线程场景</p>
<p><strong>StringJoiner</strong><br>StringJoiner基于StringBuilder构建的适用于<strong>字符拼接</strong>的场景</p>
<pre><code>    StringJoiner sj = new StringJoiner(&quot;,&quot;); // 指定分隔符
    sj.add(&quot;张三&quot;).add(&quot;李四&quot;).add(&quot;王五&quot;); // 添加元素
    String result = sj.toString(); // 转换为字符串
    System.out.println(result); // 张三,李四,王五
</code></pre>
<h3 id="字符串拼接底层原理"><a href="#字符串拼接底层原理" class="headerlink" title="字符串拼接底层原理"></a>字符串拼接底层原理</h3><p>如果没有变量参与，编译时会进行优化，<strong>编译时拼接起来，会复用常量池中的字符串</strong></p>
<pre><code>    String s1 = &quot;abc&quot;;
    String s2 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;
    System.out.println(s1==s2); // 返回true，
</code></pre>
<p>如果有变量参与，每一行拼接都会在内存中创建新字符串对象，浪费内存</p>
<h4 id="StringBuilder优化原理"><a href="#StringBuilder优化原理" class="headerlink" title="StringBuilder优化原理"></a>StringBuilder优化原理</h4><p>创建一次StringBuilder对象，所有要拼接的都往这一个对象放，节约内存</p>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>java不允许在嵌套的块中重定义变量<br>java不能实现运算符重载</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>快速打印数组</p>
<pre><code>    int[] a = new int[100];
    System.out.println(Arrays.toString(a));
</code></pre>
<p>快速打印二维数组</p>
<pre><code>    int[] a = new int[100][100];
    System.out.println(Arrays.deeptoString(a));
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/21/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/21/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-21/" class="post-title-link" itemprop="url">c++学习笔记——9.21</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-21 08:55:01 / 修改时间：12:42:53" itemprop="dateCreated datePublished" datetime="2023-09-21T08:55:01+08:00">2023-09-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h3><pre><code>    int ia[] = &#123;0, 1, 2, 3&#125;;
    int *beg = begin(ia); // 指向ia首元素的指针
    int *last = end(ia); // 指向ia尾元素的下一个位置的指针
</code></pre>
<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>当一个对象被用作右值，用的是对象的<strong>值（内容）</strong><br>当一个对象被用作左值，用的是对象的<strong>身份（在内存中的位置）</strong></p>
<h3 id="自增-自减运算符"><a href="#自增-自减运算符" class="headerlink" title="自增 自减运算符"></a>自增 自减运算符</h3><p><strong>除非必须，否则不用自增自减运算符的后置版本（i++）</strong><br>原因：后置版本会先将原始值存储下来，不必要</p>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p>函数中不会改变的形参定义为<strong>常量引用</strong></p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>1 如果所有实参类型相同，可用initialzer_list（标准库类型），initialzer_list是一个模版类型<br>        void error_msg(initialzer_list<string> i) {<br>            …<br>        }</p>
<p>2 如果实参类型不同，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/20/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/20/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-20/" class="post-title-link" itemprop="url">c++学习笔记——9.20</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-20 10:27:06 / 修改时间：12:03:56" itemprop="dateCreated datePublished" datetime="2023-09-20T10:27:06+08:00">2023-09-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>对于c++的迭代器，<strong>只有!&#x3D;</strong> 没有&lt;</p>
<p>迭代器分为两种：<br>        vector<int>::iterator it1;  &#x2F;&#x2F; 能读写<br>        vector<int>::const_iterator it2;  &#x2F;&#x2F; 只读，不能写<br>若想得到const_iterator，有<strong>cbegin(),cend();</strong></p>
<p><strong>但凡使用迭代器的循环体，都不要向容器添加元素</strong></p>
<p><strong>std::difference_type</strong> 是C++标准库中的一种类型，通常与容器迭代器相关。它是一个有符号整数类型，用于表示两个迭代器之间的距离（差异）</p>
<p>与size_type()函数类似 <strong>目的是确保在不同平台和编译器中，容器迭代器的距离计算都能正确工作，因为不同的平台和编译器可能会有不同的整数大小，保证可移植性</strong></p>
<h3 id="size-t和size-type的区别（来自chatgpt，未完全理解）"><a href="#size-t和size-type的区别（来自chatgpt，未完全理解）" class="headerlink" title="size_t和size_type的区别（来自chatgpt，未完全理解）"></a>size_t和size_type的区别（来自chatgpt，未完全理解）</h3><p><strong>size_t：</strong> size_t是C和C++<strong>标准库</strong>中定义的一种无符号整数类型，通常用于表示对象的大小、元素数量或者数组的索引，它不是一个特定容器或类型的成员</p>
<p><strong>size_type：</strong> size_type是一些<strong>标准库容器类</strong>的成员类型，例如 std::vector、std::string、std::deque等，是<strong>容器类特定</strong>的无符号整数类型，用于表示容器的大小、元素数量或者迭代器之间的距离。</p>
<p>在使用容器的成员函数时，应该使用容器的 size_type 类型，以确保代码在容器的上下文中正常工作。例如，在使用 std::vector 时，应该使用 std::vector::size_type 来表示容器的大小。</p>
<h3 id="箭头运算符-gt"><a href="#箭头运算符-gt" class="headerlink" title="箭头运算符 -&gt;"></a>箭头运算符 -&gt;</h3><p>箭头运算符 &#x3D; 解引用 + 成员访问<br>        it-&gt;mem<br>        (*it).mem<br>上面两句意思相同</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>编译时维度已知，所以维度必须是一个<strong>常量表达式</strong></p>
<p><strong>字符数组：用字符串字面值初始化字符数组时，字符串字面值的结尾有一个空字符</strong><br>        char a[] &#x3D; “Daniel”； &#x2F;&#x2F; 自动添加表示空字符串结束的空字符，所以维度为7</p>
<p><strong>使用数组下标时，通常定义为size_t类型</strong>，是一种机器相关的<strong>无符号类型</strong><br>size_t 的大小在不同的编译器和平台上可能会有所不同，但它的目的是确保能够安全地表示当前系统上的最大对象大小<br>通常被用于与内存分配和数据结构相关的操作，以确保代码的可移植性</p>
<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>从内向外看<br>int *ptr[10]; &#x2F;&#x2F; ptr是含有10个整型指针的数组<br>int (*ptr)[10] &#x3D; &amp;arr; &#x2F;&#x2F; ptr指向一个含有10个整数的数组</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/17/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/17/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-17/" class="post-title-link" itemprop="url">c++学习笔记——9.17</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-17 14:20:55" itemprop="dateCreated datePublished" datetime="2023-09-17T14:20:55+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-19 20:25:47" itemprop="dateModified" datetime="2023-09-19T20:25:47+08:00">2023-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h3><p>c++ 静态类型语言，在编译阶段检查类型</p>
<h3 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h3><p><strong>赋值永远改变的是等号左侧的对象</strong></p>
<h3 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h3><p>引用类型必须与其所引用对象的类型一致<br>        const int ci &#x3D; 1024;<br>        const int &amp;r1 &#x3D; ci;</p>
<p>常量引用：常量引用是对const的引用</p>
<p>对const的引用可能引用一个非const对象：<br>常量引用，即对引用加const，只是<strong>限定了引用可参与的操作</strong>，对于引用的对象本身没有限定<br>        int i &#x3D; 42;<br>        const int &amp;r1 &#x3D; i;<br>        r1 &#x3D; 0;  &#x2F;&#x2F; <strong>非法，常量引用不能修改</strong></p>
<h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><p>指向常量的指针和常量引用类似，<br>        const int i &#x3D; 42;<br>        const int *i &#x3D; &amp;i;<br>        *i &#x3D; 0;  &#x2F;&#x2F; <strong>非法，不能修改值</strong></p>
<h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><pre><code>    const int i = 42;
    const int *const r1 = &amp;i;
</code></pre>
<p>*<strong>const为const指针，不变的是指针本身的值，而指向的值</strong></p>
<h3 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h3><p>顶层 const 表示指针本身是个常量；<br>底层 const 表示指针所指的对象是一个常量<br>or<br>被修饰的变量本身无法改变的 const 是顶层 const；<br>通过指针或引用等间接途径来限制目标内容不可变的 const 是底层 const</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>常量表达式：值不会改变，编译过程就能得到计算结果的表达式</p>
<p>C++11:constexpr，如果认定变量是常量表达式，就声明为constexpr</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>别名声明<br>    using SI &#x3D; Sales_item;  &#x2F;&#x2F; SI是Sales_item的同义词（Sales_item是一个类型）</p>
<h3 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h3><p>预处理功能 #include，当预处理器看到#include标记时就会用指定的头文件内容代替#include</p>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>选择并返回操作数的数据类型<br>使用情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量</p>
<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h3><p>string类的配套类型，<strong>无符号类型</strong>，能足够存放下任何string对象的大小（通常等于 std::size_t）<br>访问string对象的下标也是size_type类型，<strong>使用该类型访问string中的字符可以保证安全（无符号）</strong></p>
<p>注：size()函数无符号，要避免和int类型混用带来的问题</p>
<h3 id="int类型和unsigned-int类型混用问题"><a href="#int类型和unsigned-int类型混用问题" class="headerlink" title="int类型和unsigned int类型混用问题"></a>int类型和unsigned int类型混用问题</h3><p>int和unsigned int类型进行混合算数运算时，运算结果为<strong>非负数时，结果不会出现异常</strong>，当运算结果为<strong>负数时就会出现异常结果，往往异常结果值会很大</strong></p>
<h3 id="字面值与string对象"><a href="#字面值与string对象" class="headerlink" title="字面值与string对象"></a>字面值与string对象</h3><p>字符串字面值和string是不同的类型<br>        string s1 &#x3D; “hello”;<br>        string s2 &#x3D; s1 + “test”;  &#x2F;&#x2F; 正确，会转化为string类型<br>        string “hello” + “test”;  &#x2F;&#x2F; 错误，两个都不是string类型</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/09/15/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/15/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%949-15/" class="post-title-link" itemprop="url">c++学习笔记——9.15</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-15 14:44:37" itemprop="dateCreated datePublished" datetime="2023-09-15T14:44:37+08:00">2023-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 14:20:04" itemprop="dateModified" datetime="2023-09-17T14:20:04+08:00">2023-09-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="缓冲区（buffer）"><a href="#缓冲区（buffer）" class="headerlink" title="缓冲区（buffer）"></a>缓冲区（buffer）</h3><p>一个存储区域，用于保存数据，IO设施通常将输入输出数据保存在一个缓冲区中，可以显式刷新缓冲区</p>
<h3 id="iostream对象"><a href="#iostream对象" class="headerlink" title="iostream对象"></a>iostream对象</h3><p><strong>cerr</strong>  ostream对象，标准错误流，默认不缓冲，用于输出错误信息或其他不属于程序正常逻辑的输出内容</p>
<p><strong>clog</strong> ostream对象，标准错误流，有缓冲，用于报告程序执行信息</p>
<h3 id="endl与’-n’区别"><a href="#endl与’-n’区别" class="headerlink" title="endl与’\n’区别"></a>endl与’\n’区别</h3><p>endl相当于 ‘\n’+flush()</p>
<h3 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h3><p>1 明确数值不可能为负时，选无符号<br>2 选int做整数运算，超过int用long long<br>3 选double做浮点数运算</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是具有某种数据类型的内存空间</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><ol>
<li>每个源文件（.cpp .cc等）都是一个<strong>独立的编译单元</strong>，都会被编译一遍，并生成中间文件。在 main.cpp 里，include用来【编译】时找函数声明，中间文件用来【链接】时找函数原型。</li>
<li>include简单的说就是复制粘贴而已，每个正常的头文件都会预防重复包含，如使用 #pramga once，#ifndef 等。</li>
</ol>
<p><strong>声明与定义</strong><br>c++将声明和定义区分开</p>
<p>声明 (declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明</p>
<p>定义(definition)负责<strong>创建</strong>与名字关联的实体</p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键字 extern，而且不要显式地初始化变量</p>
<pre><code>extern int i  //声明i，非定义i
int j  // 声明并定义j
</code></pre>
<p>另外，任何包含了显式初始化的声明即成为定义，如下：<br>    extern double pi &#x3D; 3.1416  &#x2F;&#x2F; 定义</p>
<h3 id="初始化建议"><a href="#初始化建议" class="headerlink" title="初始化建议"></a>初始化建议</h3><p>初始化每一个内置类型的变量</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/06/11/%E5%8D%95%E8%B0%83%E5%89%8D%E7%BC%80%E4%B8%80%E8%87%B4%E6%80%A7%E2%80%94%E2%80%94monotonic-prefix-consistency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/11/%E5%8D%95%E8%B0%83%E5%89%8D%E7%BC%80%E4%B8%80%E8%87%B4%E6%80%A7%E2%80%94%E2%80%94monotonic-prefix-consistency/" class="post-title-link" itemprop="url">单调前缀一致性——monotonic prefix consistency</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-06-11 21:00:06 / 修改时间：21:04:32" itemprop="dateCreated datePublished" datetime="2023-06-11T21:00:06+08:00">2023-06-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://thiscute.world/posts/consistency-and-consensus-algorithm/">参考链接</a></p>
<h2 id="单调前缀一致性——monotonic-prefix-consistency"><a href="#单调前缀一致性——monotonic-prefix-consistency" class="headerlink" title="单调前缀一致性——monotonic prefix consistency"></a>单调前缀一致性——monotonic prefix consistency</h2><p>在读论文C5:cloned并发控制协议论文时遇到monotonic prefix consistency，故记录在此</p>
<p><strong>前缀一致性 Consistent Prefix</strong>：副本之间的同步过程中，会存在一些副本接收数据的顺序并不一致。「前缀一致性」是说所有用户读到的数据顺序的前缀永远是一致的。</p>
<p>「前缀」是指程序在执行写操作时，需要显式声明其「前缀」事件，这样每个事件就都存在一个由其他写事件排列而成的前缀。比如当前有写事件排列「A B C D」，那所有用户读到的数据都拥有同样的写事件前缀，比如「A」、「A B」、「A B C」、「A B C D」，但不可能出现「A C」或者「C A」等结果。</p>
<p>它解决的是<strong>分片分布式数据库的一致性问题</strong>：A B C 因为地域区别读写的是不同的副本，B 在抖音评论区问了个问题，然后 A 作出了回答。但是问题跟回答两个数据如果处于不同的分片，副本同步时这两个数据的顺序是无法保证的，C 可能会先读到回答信息，之后才刷新出 B 的提问，历史事件的顺序就乱了。<br>实现方式：需要程序主动为<strong>消息之间添加显式的依赖关系</strong>，再据此控制其读取顺序，实现比较复杂。<br>存在的问题：只有被显式定义了因果关系的事件，它们之间的顺序才能被保证。</p>
<p>问题与答案之间是有因果关系的，但这种关系在复制的过程中被忽略了，于是出现了异常。<br>保持这种因果关系的一致性，被称为前缀读或前缀一致性</p>
<p><strong>前缀一致性：在每个会话内保证了单调读，会话之间不保证</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/06/10/%E7%BB%8F%E5%85%B8%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94atomic-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/10/%E7%BB%8F%E5%85%B8%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94atomic-operation/" class="post-title-link" itemprop="url">经典原子操作——atomic operation</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-06-10 13:49:48 / 修改时间：14:10:51" itemprop="dateCreated datePublished" datetime="2023-06-10T13:49:48+08:00">2023-06-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="read-modify-write（RMW）"><a href="#read-modify-write（RMW）" class="headerlink" title="read-modify-write（RMW）"></a>read-modify-write（RMW）</h2><p><strong>读-修改-写（read-modify-write）</strong> 是计算机科学中的一个原子操作（atomic operation，操作过程是<strong>读一个内存位置（或IO端口），修改其值，再写回原位置</strong>。</p>
<p><strong>“read-modify-write”（RMW）原子操作指的是一种能够在单个操作中读取、修改和写入某个内存地址的操作。</strong> 这种操作通常是在多线程编程和并发编程中使用，用于确保对共享内存的并发访问不会导致竞争条件（race condition）</p>
<p>在一个RMW原子操作中，操作系统保证该操作的执行不会被其他线程中断，也就是说，在操作开始执行到结束期间，该内存地址上的任何其他操作都将被暂停。这意味着，RMW原子操作是一种不可分割的操作，不会发生其他线程对该内存地址进行操作的情况。</p>
<p>RMW原子操作通常<strong>由硬件支持</strong></p>
<p><strong>在多线程编程中，RMW原子操作通常用于实现线程间同步、加锁、计数器等功能</strong>。例如，在一个高并发的Web服务器中，可以使用RMW原子操作来保证多个线程同时访问同一个计数器变量时的正确性，避免计数器值出现不一致的情况。</p>
<h2 id="test-and-set"><a href="#test-and-set" class="headerlink" title="test and set"></a>test and set</h2><p>在计算机科学中，<strong>检查并设置（test-and-set-lock，TSL）</strong> 是一种不可中断的原子运算。TSL<strong>对某个存储器位置写入1（set）并返回其旧值</strong>。</p>
<p>在多个进程可同时访问存储器同个地址时，如果一个程序正在执行TSL，其他程序在它执行完成前不能执行TSL。</p>
<p>TAS特点是<strong>自旋</strong>，也就是循环，每次尝试去设置值，如果设置成功则会返回，如果没有返回就会一直自旋，知道设置成功值。此时进入临界区，执行完临界区数据，再设置bool变量为false。从而让其他线程拿到锁</p>
<pre><code>function Lock(boolean *lock) &#123; 
while (test_and_set(lock) == 1); 
&#125;
</code></pre>
<h2 id="fetch-and-add"><a href="#fetch-and-add" class="headerlink" title="fetch-and-add"></a>fetch-and-add</h2><p>fetch-and-add是CPU指令（FAA），对内存位置执行增加一个数量的原子操作。具体内容为：</p>
<pre><code>令x 变为x + a，其中x是个内存位置，a是个值
</code></pre>
<p>FAA可用于实现互斥锁、信号量</p>
<h2 id="compare-and-swap"><a href="#compare-and-swap" class="headerlink" title="compare-and-swap"></a>compare-and-swap</h2><p>比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fength</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
