<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"coder_tinghao.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Feng&#39;s Blog">
<meta property="og:url" content="http://coder_tinghao.github.io/index.html">
<meta property="og:site_name" content="Feng&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fength">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://coder_tinghao.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Feng's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Feng's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Feng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">passion</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">38</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fength"
      src="/images/profile.png">
  <p class="site-author-name" itemprop="name">Fength</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/coder-tinghao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;coder-tinghao" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:793360194@qq.com" title="E-Mail → mailto:793360194@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2024/03/24/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%943-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/24/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%943-24/" class="post-title-link" itemprop="url">java学习笔记——3.24</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-24 15:20:40" itemprop="dateCreated datePublished" datetime="2024-03-24T15:20:40+08:00">2024-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-26 16:52:38" itemprop="dateModified" datetime="2024-03-26T16:52:38+08:00">2024-03-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>—— 一致性哈希算法<br><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/os/8_network_system/hash.html#%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E8%AF%B7%E6%B1%82">https://www.xiaolincoding.com/os/8_network_system/hash.html#%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E8%AF%B7%E6%B1%82</a></p>
<p>负载均衡：<br>全量存储，不需要分布式算法，根据每个机器的硬件水平，做对应请求分配即可</p>
<p>分布式存储（非全量）<br>设计：为了解决普通哈希映射在分布式场景下，添加和删除节点带来的巨大数据迁移代价</p>
<p>一致性哈希算法思想：整个映射关系用一个2^32次方的数组成的哈希环，相应的数据请求先根据哈希算法映射到哈希环一个节点上，再<strong>顺时针</strong>找下一个相邻存储节点</p>
<p>带来问题：<br>容易想到，如果最开始的单纯的映射，导致存储节点分布不均匀，很可能导致大量热点请求集中在某一个存储节点，导致一个个逐渐崩溃的节点雪崩的出现</p>
<p>解决：引入虚拟节点<br>个人理解，在最开始的单纯的映射后，为了让存储节点均匀，生成出使哈希环均匀的虚拟存储节点用于处理请求，相当于做一个二次映射，负载均衡到各个节点，避免出现请求集中</p>
<p>—— I&#x2F;O 多路复用<br><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#i-o-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#i-o-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247489558&amp;idx=1&amp;sn=7a96604032d28b8843ca89cb8c129154&amp;chksm=f98e5cbccef9d5aa249c02489614d81ce865eacb165846df84721636cd4717d1aaa830dbec56&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247489558&amp;idx=1&amp;sn=7a96604032d28b8843ca89cb8c129154&amp;chksm=f98e5cbccef9d5aa249c02489614d81ce865eacb165846df84721636cd4717d1aaa830dbec56&amp;scene=21#wechat_redirect</a></p>
<p>Redis单线程执行命令，因为Redis的性能瓶颈在网络IO和内存，不在CPU<br>但有IO多路复用，网络IO多线程</p>
<p>I&#x2F;O多路复用，一个进程去关联多个socket的请求，类似时分多路复用思想<br><strong>select&#x2F;poll&#x2F;epoll</strong> 内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件</p>
<p>select&#x2F;poll 涉及用户态和内核态之间的 两次文件描述符集合<strong>遍历</strong>和两次文件描述符集合<strong>拷贝</strong><br>使用的数据结构不同，但都是线性结构，都是O(n)的时间复杂度</p>
<p>epoll 数据结构不是线性结构，而是<strong>红黑树</strong>；且用链表存储事件，管理事件触发，就不需要轮询了<br>epoll 被称为解决 C10K 问题的利器</p>
<p>—— Redis持久化<br>AOF机制——append only file 仅以追加方式写入日志：先执行，后写日志<br>RDB快照——将某一时刻的内存数据，以二进制的方式写入磁盘<br>混合式</p>
<p>AOF文件过大，AOF重写机制——压缩AOF<br>在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 文件，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件</p>
<p>—— 僵尸进程和孤儿进程<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lushilin/p/9401494.html">https://www.cnblogs.com/lushilin/p/9401494.html</a><br>僵尸进程：子进程退出时，会保留如进程号、退出状态、运行时间等信息，等父进程调用wait &#x2F; waitpid才释放，如果父进程没调用，结束的子进程信息仍然在占用资源，就是僵尸进程</p>
<p>孤儿进程：子进程的父进程结束了，只能由init进程（进程号为1）处理</p>
<p>父子进程：（采用写时复制技术）<br>子进程的执行是从fork()函数返回的地方开始，它继承了父进程的执行上下文（例如程序计数器、寄存器等），但是它的执行是独立的，不会影响父进程的执行</p>
<p>拥有各自独立的虚拟地址空间，执行是相互独立的</p>
<p>写时复制：父进程的写操作会被复制一份，给子进程</p>
<p>—— 进程wait操作和waitpid操作<br>wait函数的作用是父进程调用，等待子进程退出，回收子进程的资源<br>waitpid 指定具体进程pid</p>
<p>—— 分布式锁<br>分布式锁：当多个进程不在同一个系统中(比如分布式系统中控制共享资源访问)，用分布式锁控制多个进程对资源的访问</p>
<p>实现方式：</p>
<ol>
<li>基于数据库表：建一个锁表，获得锁就尝试插入一条，释放锁就删除一条</li>
<li>乐观锁，MVCC</li>
<li>悲观锁，排他锁</li>
<li>基于Redis：加锁： set key NX PX + 重试 + 重试间隔<br>“NX”指的是当且仅当key在Redis中不存在时，返回执行成功，否则执行失败<br>解锁：采用lua脚本（在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致）保证原子性</li>
</ol>
<p>why？Lua 是一种单线程语言，所有的代码都在同一个线程中运行，因此不会出现并发问题。</p>
<ol start="5">
<li>zookeeper实现分布式锁：创建一个用于发号的节点“&#x2F;test&#x2F;lock”，最小号得锁</li>
</ol>
<p>—— Redis过期策略</p>
<ol>
<li>惰性过期：只有访问一个key时，才判断是否过期，过期则清除。但没有及时清除，对内存不友好</li>
<li>定期过期：每隔一段时间，扫描一定数量的带过期时间的key，</li>
</ol>
<p>—— RocksDB等NoSQL数据库<br>—— LSM-Tree<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/181498475">https://zhuanlan.zhihu.com/p/181498475</a></p>
<p>MemTable 内存中，有序组织key的结构，不同数据库有不同实现</p>
<p>Immutable MemTable 当MemTable达到一定大小时，新的写入只进入新MemTable，将ImmuTable不断刷入磁盘</p>
<p>SSTable 磁盘上的持久化存储，以append的日志形式</p>
<p>SSTable有Compact策略，分为size-tiered和leveled策略：都是多层设计</p>
<ol>
<li>size-tiered策略是，层数越深，该层的SSTable越大；每层的SSTable超过一定数量，触发合并</li>
<li>leveled策略，会将每一层切分成多个大小相近的SSTable，某层SSTable超过该层大小限制：此时会从L1中选择至少一个文件，然后把它跟L2有交集的部分(非常关键)进行合并。生成的文件会放在L2；若L2超过在合并后超过了，L2重复以上步骤向下合并</li>
</ol>
<p>—— 数据库和缓存一致性 见小林coding<br>无论先更新缓存，还是先更新数据库，都存在并发更新带来的不一致问题</p>
<p>解决：</p>
<ol>
<li><p>旁路缓存策略：<br>写策略步骤：更新数据库中的数据；删除缓存中的数据。<br>读策略步骤：如果命中缓存，直接返回数据；如果没有命中缓存，从数据库中读取数据，然后将数据写入到缓存，并且返回给用户</p>
<p>这个写策略，理论上也存在不一致的可能，即某一查询请求未命中，从数据库中查询到了数据，准备回写到缓存；此时，有另一条请求完成了从数据库中查值和删除缓存过程。<br>因为缓存速度远快于数据库，实际上不太可能出现这种情况</p>
<p>对于写策略：删除缓存中的数据；更新数据库中的数据，也有解决办法解决一致性问题：<br><strong>延时双删</strong>：就是在更新完数据库中的数据后，睡眠一段时间后，再删除缓存，尽可能确保一致性</p>
<p>加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存</p>
</li>
<li><p>如果业务对缓存命中率有很高的要求，旁路缓存粗略的删除缓存办法就不行了<br>更新数据库 + 更新缓存策略：</p>
<p>方法：</p>
<ol>
<li>更新缓存前加分布式锁</li>
<li>对每条缓存加一个较短的过期时间</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2024/03/24/3-22%E8%9A%82%E8%9A%81%E6%9A%91%E6%9C%9F%E4%B8%80%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/24/3-22%E8%9A%82%E8%9A%81%E6%9A%91%E6%9C%9F%E4%B8%80%E9%9D%A2/" class="post-title-link" itemprop="url">3-22蚂蚁暑期一面</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-24 00:06:47 / 修改时间：14:53:38" itemprop="dateCreated datePublished" datetime="2024-03-24T00:06:47+08:00">2024-03-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>3-21 二笔（3道题，45min，伪代码，反复提醒注意边界条件和极端情况）</p>
<p>1.n级台阶，一次可以走1级，2级或3级，计算走完该台阶有多少种方案？<br>面试中问：极端情况下，如果台阶数量过多，dp数组爆内存了，怎么办？</p>
<p>2.3个线程，一个线程打印“X”，一个线程打印“Y”，一个线程打印“Z”，同时执行连续10次打印“XYZ”</p>
<p>3.编写一个随机红包算法，需求为：给定一定的金额，一定的人数，保证每个人都能随机获得一些金额，最佳手气金额不能超过最大金额的90%</p>
<p>3-22 30min电话面</p>
<p>自我介绍</p>
<p>实习经历：讲自己实习中做的项目，技术难点</p>
<p>讲自己实习外的自己主导的项目，没太讲好，讲的大创，下次可以讲毕设项目和MassBFT区块链项目</p>
<p>大创项目引申到推荐算法，让我讲一个算法，真是给自己挖了个大坑。。</p>
<p>-熟悉什么语言？Java<br>Java用什么框架？<br>用什么中间件？MQ，MyBatis<br>用什么数据库？</p>
<p>-MQ 消息队列<br>消息队列作用？<br>消息队列支持事务吗？<br>消息队列出现消息堆积怎么办？<br>消息队列怎么保证消费者一定获取到消息？</p>
<p>-分布式<br>事务隔离级别<br>比如两个数据库，怎么保证一致性<br>分布式事务实现思想，随便说一个</p>
<p>-经历<br>参加过什么竞赛</p>
<p>-MySQL<br>发现查询速度慢时，怎么处理？慢查询相关<br>B+树优点<br>还知道什么索引？哈希索引<br>哈希索引优点<br>大量热点数据访问哈希索引的情况？<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26664043/article/details/135732967">https://blog.csdn.net/qq_26664043/article/details/135732967</a></p>
<p>hashCode()方法？<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6893780715860262925">https://juejin.cn/post/6893780715860262925</a><br>很多时候hashcode是对象内存地址的一个映射，但是java里面不是的。<br>实际上java默认的hashcode是由一套随机算法生成的，只与对象生成的顺序和线程有关</p>
<p>二笔题1:<br>极端情况下，如果台阶数量过多，dp数组爆内存了，怎么办？（当时不是这么问的，导致出现了理解偏差，没答出来）</p>
<p>爆内存了会出现怎么异常？OOM<br>JVM哪些区域会出现OOM？</p>
<p>-JVM<br>随便讲个垃圾回收器？G1<br>G1垃圾回收器特有的设计？</p>
<p>评价：实践经历和项目深度相对欠缺</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2024/03/21/3-21%E7%BE%8E%E5%9B%A2%E6%9A%91%E6%9C%9F%E4%B8%80%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/21/3-21%E7%BE%8E%E5%9B%A2%E6%9A%91%E6%9C%9F%E4%B8%80%E9%9D%A2/" class="post-title-link" itemprop="url">3.21美团暑期一面</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-21 12:42:39" itemprop="dateCreated datePublished" datetime="2024-03-21T12:42:39+08:00">2024-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-22 17:33:51" itemprop="dateModified" datetime="2024-03-22T17:33:51+08:00">2024-03-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>算是第一个模版式的面试 实习经历+高强度八股+两道手撕 吧，面试官比较耐心，一直在引导，说对说错会有反馈，能感受到，不像某手面试官只会笑</p>
<p>全程1h10min 1h八股+10min手撕</p>
<p>– jvm<br>jvm都有哪几部分，哪些部分会OOM，方法区怎么OOM？<br>最后方法区问题答错了，jvm没追问了</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2398572">https://cloud.tencent.com/developer/article/2398572</a></p>
<p>—— 线程池<br>为什么有线程池，假设4个核心线程，8个最大线程，队列长度为10，有20个线程，问执行过程？<br>最后会饱和，所以问了拒绝策略？</p>
<p>——— MySQL<br>熟悉哪些索引<br>聚簇索引和非聚簇索引区别</p>
<p>MySQL中的非聚簇索引实际存的是什么？</p>
<p>B树和B+树索引区别，B+树优点</p>
<p>—— 最近学了什么新技术？<br>stream<br>—— stream执行原理？<br>不会。。</p>
<p>—— 消息队列MQ，MQ应用场景？MQ底层原理？<br>不太会。没敢说会</p>
<p>—— 慢查询怎么分析？怎么处理？用什么工具？<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wzh2010/p/17091055.html">https://www.cnblogs.com/wzh2010/p/17091055.html</a></p>
<p>—— 手写单例模式，解释原理<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shoufeng/p/10820964.html">https://www.cnblogs.com/shoufeng/p/10820964.html</a></p>
<p>记得禁用构造方法</p>
<p>—— LRU原理，如果实现要怎么实现，见力扣<br>问的很细，所有结构的设计，说实话还不如让我写，抽象着叙述确实有地方没太考虑到</p>
<p>—— 给你一个展示界面，需要实现界面里多个tab的 不同类型人员的可见性，如超级管理员等，怎么实现？</p>
<p>—— 单元测试（由实习经历衍生的）<br>怎么自己测代码是不是对的</p>
<p>覆盖率，是不是走到了</p>
<p>Mock注解，IDEA自带覆盖率报告，断点Debug自己看</p>
<p>—— 手撕 LC78. 子集</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2024/01/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941-20/" class="post-title-link" itemprop="url">Java学习笔记——1.20</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-01-20 15:32:27 / 修改时间：15:42:20" itemprop="dateCreated datePublished" datetime="2024-01-20T15:32:27+08:00">2024-01-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/12/11/%E4%BA%AC%E4%B8%9C%E9%9B%B6%E5%94%AE%E2%80%94%E2%80%94%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%9412-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/11/%E4%BA%AC%E4%B8%9C%E9%9B%B6%E5%94%AE%E2%80%94%E2%80%94%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%9412-11/" class="post-title-link" itemprop="url">京东零售——一面面经——12.11</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-11 11:55:14 / 修改时间：14:37:01" itemprop="dateCreated datePublished" datetime="2023-12-11T11:55:14+08:00">2023-12-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="京东零售一面面经"><a href="#京东零售一面面经" class="headerlink" title="京东零售一面面经"></a>京东零售一面面经</h3><p>这个面试官超柔和，语速也比较慢，会给提示辅助，总体答完很舒畅，没有上次的压力和紧张感，全程几乎没八股，全是计算机基础</p>
<p>1.区块链理解</p>
<p>2.raft共识算法，PBFT共识算法<br>——raft算法都有哪几个角色，都是干嘛的<br>——PBFT共识算法和raft算法区别</p>
<p>3.C++和Java区别，谈理解</p>
<p>4.虚拟内存是什么</p>
<p>5.计算机网络五层模型，分别都做什么的，举例子<br>——Java中有没有和计算机网络这种模型相似的地方，谈谈理解</p>
<p>——答的：分层思想，解藕</p>
<p>6.网络层中最短路算法都有什么，有按边找的，有按节点找的，具体讲讲<br>——讲的不是很好，不是很流畅，面试官赶时间，讲一半pass了</p>
<p>7.C++引用和指针有什么区别<br>——没答出来，刚思考3秒钟，面试官说没事，不知道也没事什么的</p>
<p>8.讲一下聚簇索引，是什么</p>
<p>9.MySQL场景题，查百万级电话号码，对电话号码排序</p>
<p>我答：基数排序思想，按位查，然后再并行查，不知道对不对。。</p>
<p>反问：部门具体业务<br>答：数据中台，分线下和什么的忘了</p>
<p>其他的慢慢回想再写吧。。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/11/28/%E5%BF%AB%E6%89%8B%E2%80%94%E2%80%94Java%E7%94%B5%E5%95%86%E2%80%94%E2%80%94%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/28/%E5%BF%AB%E6%89%8B%E2%80%94%E2%80%94Java%E7%94%B5%E5%95%86%E2%80%94%E2%80%94%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F/" class="post-title-link" itemprop="url">快手——Java电商——一面凉经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-28 12:43:22" itemprop="dateCreated datePublished" datetime="2023-11-28T12:43:22+08:00">2023-11-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-29 16:55:18" itemprop="dateModified" datetime="2023-11-29T16:55:18+08:00">2023-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h4><p>10min项目+30min拷打<br>面试官还是很耐心的，很多问题我答的可以说很烂，最后还是愿意跟我聊问题，怎么提升</p>
<h4 id="项目亮点，收获"><a href="#项目亮点，收获" class="headerlink" title="项目亮点，收获"></a>项目亮点，收获</h4><p>表述清楚，用程序员语言描述</p>
<p><strong>不match</strong></p>
<h4 id="SQL题，统计一个小学7～12岁的年龄分布-id-name-age"><a href="#SQL题，统计一个小学7～12岁的年龄分布-id-name-age" class="headerlink" title="SQL题，统计一个小学7～12岁的年龄分布 id name age"></a>SQL题，统计一个小学7～12岁的年龄分布 id name age</h4><p>select count(id) from xxx where 7&lt;&#x3D;age ans age&lt;&#x3D;12 order by age</p>
<p>不要用等于号</p>
<h4 id="分析题"><a href="#分析题" class="headerlink" title="分析题"></a>分析题</h4><p>Integer b &#x3D; null;<br>int a &#x3D; 0;<br>a &#x3D;&#x3D; b;<br>实际上会报异常，因为Integer是一个对象，对于b来说，b&#x3D;&#x3D;null还没分配内存，还没有这个对象，根本不涉及拆箱装箱</p>
<h4 id="Object-a-x3D-new-Object-实际发生了什么"><a href="#Object-a-x3D-new-Object-实际发生了什么" class="headerlink" title="Object[] a &#x3D; new Object[]实际发生了什么"></a>Object[] a &#x3D; new Object[]实际发生了什么</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7265679390242947112">https://juejin.cn/post/7265679390242947112</a></p>
<h4 id="面向对象三大特性？封装、继承、多态"><a href="#面向对象三大特性？封装、继承、多态" class="headerlink" title="面向对象三大特性？封装、继承、多态"></a>面向对象三大特性？封装、继承、多态</h4><p>解释一下多态<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenssy/p/3372798.html">https://www.cnblogs.com/chenssy/p/3372798.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/thinkGhoster/article/details/2307001">https://blog.csdn.net/thinkGhoster/article/details/2307001</a><br>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性</p>
<p>我们只有在运行的时候才会知道引用变量所指向的具体实例对象。</p>
<p>Wine a &#x3D; new JNC();</p>
<p>在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动<strong>向上转型为Wine</strong>，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。</p>
<p>父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了</p>
<p><strong>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）</strong></p>
<h4 id="方法表角度思考多态（自）"><a href="#方法表角度思考多态（自）" class="headerlink" title="方法表角度思考多态（自）"></a>方法表角度思考多态（自）</h4><p><strong>jvm会为每一个类预先计算一个方法表，列出所有方法的签名和要调用的实际方法</strong><br>在动态方法调度中，对象可以调用子类的覆盖方法和基类的所有非覆盖方法，但是<strong>它不能调用子类中新声明的方法</strong>，我理解重载的话，和父类中的函数签名不同，也算是个新方法了，不能在动态方法中调用</p>
<p>父类的方法表肯定就只有父类的方法，子类的方法表会有所有<strong>父类中未被覆盖的方法</strong>和<strong>子类覆盖的方法</strong>和<strong>新方法和重载的方法</strong>，</p>
<h4 id="多态是在运行时还是在编译时，多态是如何实现的"><a href="#多态是在运行时还是在编译时，多态是如何实现的" class="headerlink" title="多态是在运行时还是在编译时，多态是如何实现的"></a>多态是在运行时还是在编译时，多态是如何实现的</h4><p><strong>多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</strong></p>
<p><strong>动态绑定：</strong>在<strong>运行时</strong>根据具体对象的类型进行绑定</p>
<p><strong>静态绑定：</strong>在程序执行前方法已经被绑定  <strong>编译过程确定</strong></p>
<h4 id="多态机制原则"><a href="#多态机制原则" class="headerlink" title="多态机制原则"></a>多态机制原则</h4><p><strong>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法</strong>，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</p>
<h4 id="equals-和-x3D-x3D-区别"><a href="#equals-和-x3D-x3D-区别" class="headerlink" title="equals()和&#x3D;&#x3D;区别"></a>equals()和&#x3D;&#x3D;区别</h4><p>Person a  Person b怎么equals</p>
<p>需要重写equals方法，一般认为各个字段相同，就是对象相同</p>
<h4 id="wait-和sleep-区别，哪个释放CPU资源"><a href="#wait-和sleep-区别，哪个释放CPU资源" class="headerlink" title="wait()和sleep()区别，哪个释放CPU资源"></a>wait()和sleep()区别，哪个释放CPU资源</h4><p>都释放，但sleep不释放锁资源，wait释放锁资源<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7062988072039743525">https://juejin.cn/post/7062988072039743525</a></p>
<h4 id="异常都有什么"><a href="#异常都有什么" class="headerlink" title="异常都有什么"></a>异常都有什么</h4><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/basic/java-basic-x-exception.html">https://pdai.tech/md/java/basic/java-basic-x-exception.html</a><br>答：IndexOutOfBoundsException 越界异常，被问了下异常全名<br>NullPointerException 空指针异常<br>OutOfMemoryException</p>
<p><strong>运行时异常</strong><br>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生</p>
<p><strong>非运行时异常（编译异常）</strong><br>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h4 id="OutOfMemory异常——OOM"><a href="#OutOfMemory异常——OOM" class="headerlink" title="OutOfMemory异常——OOM"></a>OutOfMemory异常——OOM</h4><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_14499/7147575">https://blog.51cto.com/u_14499/7147575</a><br>1.<strong>Java堆溢出</strong>，不断的创建对象，总容量触及最大堆的容量限制；要判断是内存泄漏还是内存溢出，如果是内存泄漏，通过Dump出来的堆转储快照进行分析，找泄漏变量的引用路径和哪些GCRoots相关联；如果是内存溢出，对象都必须活着，要么调整堆参数，要么检查是否有对象生命周期过长，存储结构设计不合理等</p>
<p>2.<strong>虚拟机栈和本地方法栈溢出</strong><br>如果线程请求的栈深度大于jvm允许的深度，StackOverflowError异常<br>如果jvm容量可以动态扩展，当扩展到无法申请到足够内存时，抛出OutOfMemoryError异常</p>
<p>3.<strong>方法区和运行时常量池溢出</strong><br>运行时常量池包括字段引用以及常量，当常量池没有足够内存可用时<br>方法区在无法满足新内存分配需求时，会OOM</p>
<p>4.<strong>本机直接内存溢出</strong><br>程序直接或间接的使用了直接内存</p>
<h4 id="什么对象不会被回收"><a href="#什么对象不会被回收" class="headerlink" title="什么对象不会被回收"></a>什么对象不会被回收</h4><p>引用计数法</p>
<p>可达性分析法</p>
<h4 id="Java线程安全"><a href="#Java线程安全" class="headerlink" title="Java线程安全"></a>Java线程安全</h4><h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a><br><strong>锁粒度问题</strong><br>1.synchronized用来标识一个<strong>普通方法</strong>，表示一个线程要执行该方法，必须取得该方法所在的<strong>对象的锁</strong></p>
<p>2.synchronized用来标识一个<strong>静态方法</strong>，表示一个线程要执行该方法，必须取得该方法所在的<strong>类的类锁</strong></p>
<p>3.synchronized用来修饰一个代码块，表示一个线程要执行该代码块，必须获得obj的锁</p>
<h4 id="Java-web流程"><a href="#Java-web流程" class="headerlink" title="Java web流程"></a>Java web流程</h4><p>比如一个手机想客户端发请求，到返回请求，处理流程</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/11/24/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/24/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-24/" class="post-title-link" itemprop="url">java学习笔记——11.24</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-24 10:39:52" itemprop="dateCreated datePublished" datetime="2023-11-24T10:39:52+08:00">2023-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-27 13:15:19" itemprop="dateModified" datetime="2023-11-27T13:15:19+08:00">2023-11-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>保证一个类只能有一个实例，并提供一个全局访问点</p>
<p>单例类的构造函数必须是私有的，这样才能将类的创建权控制在类的内部，从而使得类的外部不能创建类的实例；单例类通过一个私有的静态变量来存储其唯一实例；单例类通过提供一个公开的静态方法，使得外部使用者可以访问类的唯一实例</p>
<p>1.饿汉式</p>
<pre><code>public class Singleton &#123; 
    private static final Singleton instance = new Singleton();
    
    private Singleton () &#123;&#125;
    
    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<p>优点：线程安全，获取单例对象不需加锁<br>缺点：不是延时加载</p>
<p>2.懒汉式</p>
<p>懒汉式为了支持延时加载，将对象的创建延迟到了获取对象的时候，但为了线程安全，不得不为获取对象的操作加锁；并且这把锁只有在第一次创建对象时有用，而之后每次获取对象，这把锁都是一个累赘</p>
<pre><code>public class Singleton &#123; 
    private static final Singleton instance;
    
    private Singleton () &#123;&#125;
    
    public static synchronized Singleton getInstance() &#123;    
        if (instance == null) &#123;      
        instance = new Singleton();    
        &#125;    

        return instance;  
    &#125;
&#125;
</code></pre>
<p>3.双重检测，懒汉式plus<br>    public class Singleton {<br>        private static Singleton instance;</p>
<pre><code>    private Singleton () &#123;&#125;
    
    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
        synchronized(Singleton.class) &#123; // 注意这里是类级别的锁
            if (instance == null) &#123;       // 这里的检测避免多线程并发时多次创建对象
            instance = new Singleton();
            &#125;
        &#125;
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>将锁方法变成锁代码块</p>
<p>第二次校验是关键，这里防止了多线程创建多个实例（一般为两个），这里的特殊情况是这样的：在未创建实例的情况下，A线程和B线程都通过了第一次校验（singletonDoubleCheck为空）,<strong>这时如果通过竞争B线程拿到了锁就会执行一次new操作，生成一个实例，然后B执行完了A就会拿到资源的锁，如果没有第二次判断的话，这时A线程也会执行一次new操作，这里就出现了第二个类实例，违背了单例原则</strong>。所以说两次校验都是必不可少的。</p>
<p>作者：chenq877<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7049327348784562213">https://juejin.cn/post/7049327348784562213</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>参考链接<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/codeshell/p/14177102.html">https://www.cnblogs.com/codeshell/p/14177102.html</a></p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的接口来创建不同类型的对象。</p>
<h3 id="Java-GC机制"><a href="#Java-GC机制" class="headerlink" title="Java GC机制"></a>Java GC机制</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对象中引用计数器，为0时回收</p>
<p>问题：当有对象相互引用时，无法回收</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>GC Root Set<br>通过一系列称为<strong>GC Roots</strong>的根对象作为起始节点集，搜索引用链</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><strong>强引用</strong> 赋值引用</p>
<p><strong>软引用</strong> 有用，非必须，OOM前会回收</p>
<p><strong>弱引用</strong> 有用，非必须。下一次垃圾收集前回收</p>
<p><strong>虚引用</strong> 即将被回收，通知系统回收</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>两个分代假说：<br><strong>1.弱分代假说</strong>：绝大多数对象都是朝生夕死的</p>
<p><strong>2.强分代假说</strong>：熬过越多次垃圾收集过程的对象越难消亡</p>
<p><strong>3.跨代引用假说</strong>：跨代引用相对于同代引用来说，只占极少数<br>只需在新生代建立一个全局数据结构，把老年代划分为若干小块，表示哪一块存在跨代引用</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>1.对需要回收的对象打标记<br>2.对存活的对象打标记</p>
<p><strong>问题：</strong><br>1.<strong>对象较多时，标记开销会很大</strong><br>2.只标记清除，不整理，会存在<strong>内存碎片化</strong>问题；内存分配可能效率低</p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>分1：1的两个半区，当当前半区内存用完时，每次将存活的对象复制到另外的半区</p>
<p>问题：每次有一半内存没用上，浪费了</p>
<p>假设：新生代中98%的对象活不过第一轮收集<br><strong>优化：Eden空间 + 2个Survivor空间（Eden和Survivor空间比，8:1）</strong><br>若Survivor装不下，直接进入老年代</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>每次让存活的对象都向内存空间另一端移动，然后直接清理边界以外的内存</p>
<p><strong>和清除对比：移动的话，内存回收代价大；清除的话，内存分配代价大</strong><br>也可以两者结合，自然的，先清除，碎片化程度太大时进行移动即可</p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>白色：没访问到<br>灰色：这个对象上至少还有一个引用没扫描过<br>黑色：这个对象被访问，且所有引用都已经被扫描过</p>
<p>对象消失问题：书P89例子<br>增量更新：黑色对象插入新的指向白色的引用，记录下来，最后重新扫描<br>原始快照（SATB）：灰色对象要删除指向白色的对象引用时，记录下来，最后重新扫描</p>
<h3 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>新生代，<strong>单线程</strong>，需要暂停其他所有工作线程<br>新生代采用复制算法，老年代采用标记-整理算法</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>老年代，标记-整理算法</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>Serial收集器的多线程版本，对于新生代的收集，采用<strong>多GC线程</strong>复制算法</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>新生代，标记-复制算法，<strong>期望达到一个可控制的吞吐量</strong></p>
<p>参数：MaxGCPauseMills最大GC停顿时间；GCTimeRatio直接设置吞吐量大小</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Scavenge的老年代版本，多线程收集，标记-整理算法</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>四个步骤：（标记-清除算法）</p>
<p><strong>初始标记</strong> 标记GC Roots直接关联到的对象，需要停顿</p>
<p><strong>并发标记</strong> 可达性分析，遍历整个对象图，但和用户进程并发进行，不需要停顿</p>
<p><strong>重新标记</strong> 修正并发标记期间，标记产生变动的那一部分对象的标记记录，需要停顿</p>
<p><strong>并发清除</strong> 清除标记阶段判断的已经死亡的对象，不需要停顿</p>
<p>缺点：<br>1.无法处理浮动垃圾，我理解就是并发标记期间，得给那些新对象预留空间，避免堆满触发FullGC<br>2.因为是标记-清除算法，存在内存碎片问题</p>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>基于Region的堆内存布局，划分为多个相同大小的独立Region，可以扮演Eden，Suvivor，老年代空间的不同角色</p>
<p>还有特殊的Humongous区域用来专门存储大对象（超过一个Region空间一半）</p>
<p><strong>回收思路：</strong>跟踪各个Region中垃圾堆积的<strong>价值大小</strong>，即回收所获得的空间和回收所需时间的经验值，再维护一个<strong>优先级列表</strong></p>
<p>四个步骤</p>
<p>初始标记 标记GC Roots直接关联到的对象，需要停顿</p>
<p>并发标记 可达性分析</p>
<p>最终标记 处理遗留下来的少量SATB记录</p>
<p>筛选回收 更新Region统计数据，根据价值和成本排序，回收</p>
<p>缺点：内存占用和程序运行的额外执行负载更高</p>
<h4 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h4><p>Region分为小型Region、中型Region、大型Region</p>
<p>染色指针</p>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>1.加载，通过一个类的全限定名获取二进制字节流，将字节流所代表的静态存储结构转化为方法区的运行时数据结构，生成一个java.lang.Class对象</p>
<p>2.验证，验证这个class文件，包括文件格式校验、元数 据验证，字节码校验</p>
<p>3.准备，对这个对象分配内存，仅类变量，且通常情况赋值0，而不是代码中的值；仅在final修饰的常量值赋值代码中的值</p>
<p>4.解析，将符号引用转化为直接引用</p>
<p>5.初始化，执行构造器代码</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>判断两个类是否相等：<strong>来源于同一个Class文件+同一个Java类加载器加载</strong></p>
<p><strong>从Java虚拟机角度看</strong>，只有两种类加载器：<br>1.启动类加载器，是虚拟机自身的一部分</p>
<p>2.其他所有类的加载器，独立于虚拟机之外，继承自java.lang.ClassLoader</p>
<p><strong>从Java开发人员角度看</strong>，有三种类加载器：<br>1.启动类加载器，用来加载 java 核心类库，无法被 java 程序直接引用</p>
<p>2.扩展类加载器，用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个<br>扩展库目录。该类加载器在此目录里面查找并加载 Java 类</p>
<p>3.应用程序类加载器，通过继承 java.lang.ClassLoader 类的方式实现</p>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>工作过程：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达<strong>顶层的启动类加载器</strong>，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</p>
<h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Hs411j73w/?share_source=copy_web&amp;vd_source=b9fdf8380afcac3eebf150a26e73ff50">https://www.bilibili.com/video/BV1Hs411j73w/?share_source=copy_web&amp;vd_source=b9fdf8380afcac3eebf150a26e73ff50</a></p>
<p>普通哈希算法在服务器数量变化时的缓存失效，雪崩问题</p>
<p>一致性哈希只影响部分资源，其余部分资源不受影响</p>
<h4 id="缓存偏斜问题"><a href="#缓存偏斜问题" class="headerlink" title="缓存偏斜问题"></a>缓存偏斜问题</h4><p>引入虚拟节点，平衡访问</p>
<h4 id="减少哈希冲突"><a href="#减少哈希冲突" class="headerlink" title="减少哈希冲突"></a>减少哈希冲突</h4><p>Redis——<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2313606">https://cloud.tencent.com/developer/article/2313606</a><br>rehash：Redis的rehash是指在哈希表扩容或缩小时，重新计算并重新分配所有键值对的过程。rehash的目的是为了保持哈希表的负载因子在一个合理的范围内，以提高哈希表的性能。</p>
<p>在Redis中，rehash是一个渐进式的过程，它不会一次性地将所有键值对重新分配到新的哈希表中，而是分多次进行，每次处理一小部分键值对。这种渐进式的rehash过程可以保证在rehash期间，Redis仍然可以正常处理读取和写入操作，不会阻塞客户端请求</p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>具体的rehash过程如下：</p>
<p><strong>1.Redis会创建一个新的空哈希表，大小是当前哈希表的两倍（或更小，如果是缩小操作）。</strong><br>2.Redis会将当前哈希表的rehashidx属性设置为0，表示rehash的起始位置。<br>3.<strong>在每次执行读取或写入操作时，Redis会同时对当前哈希表和新哈希表进行操作。</strong><br><strong>4.对于读取操作，Redis首先在当前哈希表中查找键值对，如果找不到，则继续在新哈希表中查找。</strong><br><strong>5.对于写入操作，Redis会将新的键值对添加到新哈希表中，同时保留当前哈希表中的键值对。</strong><br><strong>6.在每次执行完一定数量的操作后，Redis会逐步将当前哈希表中的键值对迁移到新哈希表中，直到迁移完成。</strong></p>
<h4 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h4><p><strong>字符串String</strong></p>
<p><strong>列表List</strong><br><strong>压缩列表（Ziplist）和双向链表（Doubly Linked List）</strong><br>列表长度和列表元素大小超过一定阈值，改为双向链表</p>
<p><strong>集合Set</strong><br><strong>哈希表（Hash Table）和跳跃表（Skip List）</strong></p>
<p>哈希表适用于存储大量元素的集合，并且对于查找操作的性能要求较高</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/11/22/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/22/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-22/" class="post-title-link" itemprop="url">java学习笔记——11.22</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-22 11:21:45" itemprop="dateCreated datePublished" datetime="2023-11-22T11:21:45+08:00">2023-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-24 10:39:30" itemprop="dateModified" datetime="2023-11-24T10:39:30+08:00">2023-11-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Innodb事务"><a href="#Innodb事务" class="headerlink" title="Innodb事务"></a>Innodb事务</h3><p><strong>redo log</strong><br>redo log就是保存执行的SQL语句到一个指定的Log文件，当Mysql执行recovery时重新执行redo log记录的SQL操作即可,当客户端执行每条SQL(更新语句)时，redo log会被首先写入log buffer;当客户端执行COMMIT命令时，log buffer中的内容会被视情况刷新到磁盘</p>
<p><strong>undo log</strong><br>undo log是为回滚而用，就是copy事务前的数据库内容(行)到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘</p>
<h3 id="Java内存泄漏"><a href="#Java内存泄漏" class="headerlink" title="Java内存泄漏"></a>Java内存泄漏</h3><p>未引用对象将会被垃圾回收器回收，而引用对象却不会。<br>未引用对象很显然是无用的对象，有一些无用对象也有可能是引用对象，<strong>这部分对象正是内存泄露的来源</strong></p>
<p><strong>为什么会发生？</strong><br>对象A引用对象B，A的生命周期(t1- t4)比B的生命周期(t2-t3)要长，当B在程序中不再被使用的时候，A仍然引用着B。在这种情况下， 垃圾回收器是不会回收B对象的，这就可能造成了内存不足问题</p>
<p>因为A可能不止引用着B对象，还可能 引用其它生命周期比A短的对象，这就造成了大量无用对象不能被回收，且占据了昂贵的内存资源。</p>
<p>同样的，B对象也可能引用着一大堆对象，这些被B对象引用着的对象也不能被垃圾回收器回收，所有的 这些无用对象消耗了大量内存资源。</p>
<p><strong>如何阻止？</strong><br>使用集合、大对象、文件等时，及时赋值为null或关闭</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>工作原理</strong><br>刚开始都是在创建新的线程，达到<strong>核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列</strong>，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线 程数量10个，后面的任务则根据配置的饱和策略来处理<br><img data-src="/image.png" alt="Alt text"><br><strong>优点</strong><br>1、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用</p>
<p>2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃</p>
<p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="Executor框架两级调度（Java岗面试核心MCA版-P458）"><a href="#Executor框架两级调度（Java岗面试核心MCA版-P458）" class="headerlink" title="Executor框架两级调度（Java岗面试核心MCA版 P458）"></a>Executor框架两级调度（Java岗面试核心MCA版 P458）</h3><p>在上层，JAVA程序会将应用分解为多个任务，然后使用应用级的调度器(Executor)将这些任务映射成固定数量的线程;在底层，操作系统内核将这些线程映射到硬件处理器上</p>
<p>Runnable和Callable是工作单元(也就是俗称的任务)，执行机制由Executor来提 供。Executor是基于<strong>生产者消费者模式</strong></p>
<h3 id="线程池与线程组"><a href="#线程池与线程组" class="headerlink" title="线程池与线程组"></a>线程池与线程组</h3><p><strong>线程组</strong>就表示一个线程的集合</p>
<p><strong>线程池</strong>是为<strong>线程的生命周期开销问题和资源不足问题</strong>提供解决方案，主要用来管理线程；如果每当一个请求到达就创建一个新线程，开销是相当大的</p>
<p><strong>Callable是Runnable封装的异步运算任务<br>Future用来保存Callable异步运算的结果<br>FutureTask封装Future的实体类</strong></p>
<h3 id="Callable与Runnbale的区别"><a href="#Callable与Runnbale的区别" class="headerlink" title="Callable与Runnbale的区别"></a>Callable与Runnbale的区别</h3><p>a、Callable定义的方法是call，而Runnable定义的方法是run<br>b、call方法有返回值，而run方法是没有返回值的<br>c、call方法可以抛出异常，而run方法不能抛出异常</p>
<pre><code>public class MyCallableTask implements Callable&lt;Integer&gt; &#123;
@Override
public Integer call()
&#123;
        System.out.println(&quot;callable do somothing&quot;);
        Thread.sleep(5000);
        return new Random().nextInt(100);
    &#125;
&#125;

Callable&lt;Integer&gt; callable = new MyCallableTask();
FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable);
Thread thread = new Thread(future);
thread.start();
Thread.sleep(100);
future.cancel(true);
</code></pre>
<h3 id="什么是线程安全，如何实现线程安全"><a href="#什么是线程安全，如何实现线程安全" class="headerlink" title="什么是线程安全，如何实现线程安全"></a>什么是线程安全，如何实现线程安全</h3><p>线程安全：线程执行过程中不会产生共享资源的冲突<br>线程不安全：如果有多个线程同时在操作主内存中的变量</p>
<h3 id="Java多线程安全机制"><a href="#Java多线程安全机制" class="headerlink" title="Java多线程安全机制"></a>Java多线程安全机制</h3><h4 id="互斥同步（阻塞同步，悲观）"><a href="#互斥同步（阻塞同步，悲观）" class="headerlink" title="互斥同步（阻塞同步，悲观）"></a>互斥同步（阻塞同步，悲观）</h4><p>最基本的就是<strong>synchronized关键字</strong>，执行时，会有monitorenter指令和monitorexit指令，monitorenter指令尝试获取对象的锁，或者给锁的计数器加1；monitorexit指令会给锁的计数器减1，获取失败就阻塞等待</p>
<p>还有java.util.concurrent包中的<strong>ReentrantLock重入锁</strong>，基本用法相似，目前性能接近</p>
<h4 id="非阻塞同步（乐观）"><a href="#非阻塞同步（乐观）" class="headerlink" title="非阻塞同步（乐观）"></a>非阻塞同步（乐观）</h4><p><strong>操作和冲突检测，具备原子性</strong><br><strong>Test-and-Set, Fetch-and-Increment, Swap, Compare-and-Swap(CAS)</strong></p>
<h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>一个变量被定义为volatile后，保证此变量对<strong>所有线程可见性</strong>，普通变量做不到，因为普通变量在线程间传递需要通过主内存</p>
<p><strong>volatile变量在使用之前需要先从主内存刷新最新的值</strong>，执行引擎看不到不一致的情况，但是Java内的运算操作符不是原子操作，所以若不满足以下两条规则，仍要通过加锁保证原子性：</p>
<p>1.运算结果不依赖变量当前值，或只有单一线程修改变量值</p>
<p>2.变量不需要与其他状态变量共同参与不变约束</p>
<p>Java虚拟机书P446有例子，<strong>volatile关键字很适合控制并发（状态标志），例如：其他线程看到某一标志变量变化了，就停止线程</strong></p>
<h4 id="禁止指令重排序优化"><a href="#禁止指令重排序优化" class="headerlink" title="禁止指令重排序优化"></a>禁止指令重排序优化</h4><p>volatile修饰的变量会建立<strong>内存屏障</strong>，指重排序不能把后面的指令重排序到内存屏障之前的位置，例如：<strong>lock</strong> addl xxxxx</p>
<p>其中，<strong>lock前缀将本处理器的缓存写入内存，同时其他处理器缓存无效化</strong>，就建立了内存屏障</p>
<p><strong>synchronized关键字，一个变量在同一个时刻只允许一条线程进行lock操作</strong></p>
<h3 id="synchronized、volatile区别"><a href="#synchronized、volatile区别" class="headerlink" title="synchronized、volatile区别"></a>synchronized、volatile区别</h3><p>volatile仅能使用在<strong>变量级别</strong>，仅能实现变量的修改可见性，<strong>不能保证原子性</strong>，<strong>不会被编译器优化</strong></p>
<p>synchronized则可以使用在<strong>变量、方法、和类级别</strong>的，可以保证变量的修改可见性和原子性，因为线程获得锁才能进入临界区，<strong>可以被编译器优化</strong></p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>处理器与内存之间——高速缓存</p>
<p>多个处理器，多个缓存，共享内存，带来的<strong>缓存一致性问题</strong></p>
<p>通过缓存一致性协议协调</p>
<p><strong>happens-before规则</strong></p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><strong>ThreadLocal是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰</strong></p>
<p>每个Thread线程内部都有一个ThreadLocalMap。<br>Map里面存储线程本地对象ThreadLocal（key）和线程的变量副本（value）</p>
<p>Thread内部的Map是由ThreadLocal维护，ThreadLocal负责向map获取和设置线程的变量值。<br>一个Thread可以有多个ThreadLocal</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构<br>利用了CAS对数组的某个位置进行并发安全的赋值</p>
<h3 id="CAS（Compare-and-Swap）"><a href="#CAS（Compare-and-Swap）" class="headerlink" title="CAS（Compare-and-Swap）"></a>CAS（Compare-and-Swap）</h3><p>CAS指令需要三个操作数，分别是内存地址（在Java内存模型中可以简单理解为主内存中变量的内存地址）、旧值（在Java内存模型中，可以理解工作内存中缓存的主内存的变量的值）和新值。<strong>CAS操作执行时，当且仅当主内存对应的值等于旧值时，处理器用新值去更新旧值，否则它就不执行更新</strong>。但是无论是否更新了主内存中的值，都会返回旧值，上述的处理过程是一个原子操作。<br>如果线程中的值和主内存中的值不一致，根据缓存一致性原则，会重新去主内存读取a的值（11）</p>
<p><strong>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。</strong></p>
<h3 id="CountDownLatch、CyclicBarrier、Semaphore的用法和区别"><a href="#CountDownLatch、CyclicBarrier、Semaphore的用法和区别" class="headerlink" title="CountDownLatch、CyclicBarrier、Semaphore的用法和区别"></a>CountDownLatch、CyclicBarrier、Semaphore的用法和区别</h3><p>CountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了</p>
<p>回环屏障，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用</p>
<p>Semaphore翻译成字面意思为 信号量，Semaphore 可以同时让多个线程同时访问共享资源，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/11/21/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/21/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-21/" class="post-title-link" itemprop="url">java学习笔记——11.21</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-21 17:21:09 / 修改时间：22:04:47" itemprop="dateCreated datePublished" datetime="2023-11-21T17:21:09+08:00">2023-11-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><strong>b树索引</strong><br><strong>B树可以在内部节点同时存储键和值</strong>，频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率，键和值存放在内部节点和叶子节点</p>
<p><strong>b+树索引</strong><br><strong>B+树的内部节点只存放键，不存放值</strong>，叶子节点有一条链相连，天然<strong>支持范围查询</strong></p>
<p>当需要进行一次全数据遍历的时候，B+树只需 要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可</p>
<p><strong>hash索引</strong>，不支持范围查，查询效率不稳定</p>
<p>较频繁作为<strong>查询条件</strong>的字段才去创建索引，<strong>更新频繁字段</strong>不适合创建索引</p>
<h3 id="为什么用B-树而不是B树"><a href="#为什么用B-树而不是B树" class="headerlink" title="为什么用B+树而不是B树"></a>为什么用B+树而不是B树</h3><p><strong>B树</strong><br>随机检索<br>元素遍历（范围查询）效率低下</p>
<p><strong>B+树</strong><br>同时支持随机检索和顺序检索<br>内部结点不存值，比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，<strong>IO读写次数</strong>也就降低了</p>
<h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>聚簇索引：数据存储与索引放到了一块，找到索引也就找到了数据；叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据</p>
<p>非聚簇索引：数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，通过 key_buffer把索引先<strong>缓存到内存中</strong>；叶子节点存储的是主键信息，所以使用非聚簇索引还需要<strong>回表查询</strong></p>
<p>聚簇索引一般是主键索引，一个表中也只能有一个，而非聚簇索引则没有数量上的限制</p>
<h3 id="一定需要回表查询吗？"><a href="#一定需要回表查询吗？" class="headerlink" title="一定需要回表查询吗？"></a>一定需要回表查询吗？</h3><p>不一定，取决于<strong>查询语句所要求的字段是否全部命中了索引</strong>，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询</p>
<h3 id="MySQL隔离级别"><a href="#MySQL隔离级别" class="headerlink" title="MySQL隔离级别"></a>MySQL隔离级别</h3><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读 取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ(可重读)并不会有 任何性能损失<br><strong>InnoDB 存储引擎在 分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别</strong></p>
<h3 id="隔离级别和锁"><a href="#隔离级别和锁" class="headerlink" title="隔离级别和锁"></a>隔离级别和锁</h3><p>在Read Uncommitted级别下，<strong>读取数据不需要加共享锁</strong>，这样就不会跟被修<br>改的数据上的排他锁冲突</p>
<p>在Read Committed级别下，<strong>读操作需要加共享锁</strong>，但是在语句<strong>执行完以后释放共享锁</strong></p>
<p>在Repeatable Read级别下，<strong>读操作需要加共享锁，但是在事务提交之前并不释放共享锁</strong>，也就是必须等待事务执行完毕以后才释放共享锁</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成</p>
<h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><p>行级锁、表级锁、页级锁；具体还分<strong>共享锁和排他锁</strong> 还有<strong>意向锁（预先通知）</strong><br>InnoDB支持行级锁和表级锁，<strong>默认为行级锁</strong></p>
<p><strong>行级锁</strong> 开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低；并发度最高</p>
<p><strong>表级锁</strong> 开销小，加锁快;不会出现死锁（也有可能吧）;锁定粒度大，发出锁冲突的概率最高</p>
<p><strong>页级锁</strong> 中间</p>
<h3 id="MySQL行锁"><a href="#MySQL行锁" class="headerlink" title="MySQL行锁"></a>MySQL行锁</h3><p>InnoDB是基于<strong>索引</strong>来完成行锁<br>例: select * from tab_with_index where id &#x3D; 1 for update;<br>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id不是索引键那么InnoDB将 完成表锁，并发将无从谈起</p>
<h3 id="InnoDB存储引擎的锁"><a href="#InnoDB存储引擎的锁" class="headerlink" title="InnoDB存储引擎的锁"></a>InnoDB存储引擎的锁</h3><p>Record lock:单个行记录上的锁<br>Gap lock:间隙锁，锁定一个范围，不包括记录本身<br>Next-key lock:record+gap 锁定一个范围，包含记录本身</p>
<p>Gap Lock 的作用是为了<strong>阻止多个事务将记录插入到同一个范围内</strong>，因为这会导致幻读问题（phantom Problem）的产生</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>虚拟表</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://coder_tinghao.github.io/2023/11/20/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/profile.png">
      <meta itemprop="name" content="Fength">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feng's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Feng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/20/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%9411-20/" class="post-title-link" itemprop="url">java学习笔记——11.20</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-20 19:59:31" itemprop="dateCreated datePublished" datetime="2023-11-20T19:59:31+08:00">2023-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-21 16:08:17" itemprop="dateModified" datetime="2023-11-21T16:08:17+08:00">2023-11-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>Java集合由两大接口派生：<strong>Collection接口、Map接口</strong><br>Collection接口下面，有三个主要的子接口：<strong>List、Set 和 Queue</strong></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>ArrayList，底层用**Object[]**存储，线程不安全，适用于频繁查找，支持快速随机访问（实现了RandomAccess接口）</p>
<p>Vector，底层用**Object[]**存储，线程安全</p>
<p>LinkedList底层用<strong>双向链表</strong>，一般是不会使用到LinkedList，需要用到 LinkedList的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet，底层基于HashMap实现，保存元素，用于不需要保证元素插入和取出顺序的场景</p>
<p>LinkedHashSet，通过 LinkedHashMap来实现，链表和哈希表，<strong>元素的插入和取出顺序满足 FIFO</strong></p>
<p>TreeSet，红黑树，支持对元素自定义排序规则的场景</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>PriorityQueue，Object[]数组来实现小顶堆</p>
<p>DelayQueue，只有到了其指定的延迟时间，才能够从队列中出队</p>
<p>ArrayDeque，可扩容动态双向数组</p>
<h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>双端队列，扩展了Queue接口</p>
<h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h3><p>ArrayDeque 是基于<strong>可变长的数组和双指针</strong>来实现，而 LinkedList 则通过<strong>链表</strong>实现</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>HashMap，<strong>数组+链表</strong>，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p>
<p>LinkedHashMap，</p>
<p>Hashtable，数组+链表，比HashMap多了个<strong>线程安全</strong></p>
<p>TreeMap，红黑树</p>
<p>ConcurrentHashMap，<strong>并发环境</strong>下，推荐使用</p>
<h3 id="Java集合fail-last机制"><a href="#Java集合fail-last机制" class="headerlink" title="Java集合fail-last机制"></a>Java集合fail-last机制</h3><p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件</p>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在 被遍历期间如果内容发生变化，就会改变modCount 的值。每当迭代器使用hashNext()&#x2F;next()遍历下一 个元素之前，都会检测 modCount变量是否为expectedmodCount值，是的话就返回遍历;否则抛出 异常，终止遍历</p>
<p><strong>不要在 foreach 循环里进行元素的 remove&#x2F;add 操作</strong>，remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。通过反编译你会发现 foreach 语法底层其实还是依赖 Iterator 。不过， <strong>remove&#x2F;add 操作直接调用的是集合自己的方法，而不是 Iterator 的 remove&#x2F;add方法，迭代器就会发现自己有元素被remove&#x2F;add，就抛异常了</strong></p>
<p>除了使用Iterator进行遍历操作外：<br>使用 fail-safe 的集合类，<br><strong>java.util包下面的所有的集合类都是 fail-fast 的，而java.util.concurrent包下面的所有的类都是 fail-safe</strong></p>
<h3 id="集合只读"><a href="#集合只读" class="headerlink" title="集合只读"></a>集合只读</h3><p>Collections. unmodifiableCollection(Collection c)方法来创建一个 只读集合，改变集合 的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常</p>
<h3 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h3><pre><code>List&lt;String&gt; list = new ArrayList
Iterator&lt;String&gt; it = list. iterator
while(it. hasNext())&#123;
    String obj = it. next();
    System. out. println(obj);
&#125;
</code></pre>
<p>在当前遍历 的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常，如果要删除元素就用iterator.remove()</p>
<h3 id="Iterator与ListIterator"><a href="#Iterator与ListIterator" class="headerlink" title="Iterator与ListIterator"></a>Iterator与ListIterator</h3><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List<br>Iterator 只能<strong>单向遍历</strong>，而 ListIterator 可以<strong>双向遍历(向前&#x2F;后遍历)</strong></p>
<h3 id="List遍历的最佳实践"><a href="#List遍历的最佳实践" class="headerlink" title="List遍历的最佳实践"></a>List遍历的最佳实践</h3><p><strong>支持 Random Access 的列表可用 for 循环遍历，否则建议 用 Iterator 或 foreach 遍历</strong></p>
<h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p>Comparable 接口实际上是出自java.lang包，它有一个 c**ompareTo(Object obj)**方法用来排序</p>
<p>Comparator接口实际上是出自 java.util 包它有一个c**ompare(Object obj1, Object obj2)**方法用来排序</p>
<h3 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h3><p><strong>可以利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作</strong>，避免使用 List 的 contains() 进行遍历去重或者判断包含操作</p>
<p>HashSet 的 contains() 方法底部依赖的 HashMap 的 containsKey() 方法，时间复杂度接近于<strong>O（1）</strong></p>
<p>ArrayList 的 contains() 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 <strong>O(n)</strong></p>
<h3 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h3><p>当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 List 的唯一元素就是这个数组</p>
<p>Arrays.asList()方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类</p>
<p>List.of()方法适用于需要创建一组固定的、不可变的元素列表的场景</p>
<h3 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h3><p>处理纯文本数据，优先考虑使用字符流，除此之外都使用字节流</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fength</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
